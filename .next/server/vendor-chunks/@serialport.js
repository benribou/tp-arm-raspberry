"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@serialport";
exports.ids = ["vendor-chunks/@serialport"];
exports.modules = {

/***/ "(rsc)/./node_modules/@serialport/binding-mock/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@serialport/binding-mock/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar debugFactory = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debugFactory__default = /*#__PURE__*/_interopDefaultLegacy(debugFactory);\n\nconst debug = debugFactory__default[\"default\"]('serialport/binding-mock');\nlet ports = {};\nlet serialNumber = 0;\nfunction resolveNextTick() {\n    return new Promise(resolve => process.nextTick(() => resolve()));\n}\nclass CanceledError extends Error {\n    constructor(message) {\n        super(message);\n        this.canceled = true;\n    }\n}\nconst MockBinding = {\n    reset() {\n        ports = {};\n        serialNumber = 0;\n    },\n    // Create a mock port\n    createPort(path, options = {}) {\n        serialNumber++;\n        const optWithDefaults = Object.assign({ echo: false, record: false, manufacturer: 'The J5 Robotics Company', vendorId: undefined, productId: undefined, maxReadSize: 1024 }, options);\n        ports[path] = {\n            data: Buffer.alloc(0),\n            echo: optWithDefaults.echo,\n            record: optWithDefaults.record,\n            readyData: optWithDefaults.readyData,\n            maxReadSize: optWithDefaults.maxReadSize,\n            info: {\n                path,\n                manufacturer: optWithDefaults.manufacturer,\n                serialNumber: `${serialNumber}`,\n                pnpId: undefined,\n                locationId: undefined,\n                vendorId: optWithDefaults.vendorId,\n                productId: optWithDefaults.productId,\n            },\n        };\n        debug(serialNumber, 'created port', JSON.stringify({ path, opt: options }));\n    },\n    async list() {\n        debug(null, 'list');\n        return Object.values(ports).map(port => port.info);\n    },\n    async open(options) {\n        var _a;\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const { path } = openOptions;\n        debug(null, `open: opening path ${path}`);\n        const port = ports[path];\n        await resolveNextTick();\n        if (!port) {\n            throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);\n        }\n        const serialNumber = port.info.serialNumber;\n        if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {\n            debug(serialNumber, 'open: Port is locked cannot open');\n            throw new Error('Port is locked cannot open');\n        }\n        debug(serialNumber, `open: opened path ${path}`);\n        port.openOpt = Object.assign({}, openOptions);\n        return new MockPortBinding(port, openOptions);\n    },\n};\n/**\n * Mock bindings for pretend serialport access\n */\nclass MockPortBinding {\n    constructor(port, openOptions) {\n        this.port = port;\n        this.openOptions = openOptions;\n        this.pendingRead = null;\n        this.isOpen = true;\n        this.lastWrite = null;\n        this.recording = Buffer.alloc(0);\n        this.writeOperation = null; // in flight promise or null\n        this.serialNumber = port.info.serialNumber;\n        if (port.readyData) {\n            const data = port.readyData;\n            process.nextTick(() => {\n                if (this.isOpen) {\n                    debug(this.serialNumber, 'emitting ready data');\n                    this.emitData(data);\n                }\n            });\n        }\n    }\n    // Emit data on a mock port\n    emitData(data) {\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port must be open to pretend to receive data');\n        }\n        const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);\n        debug(this.serialNumber, 'emitting data - pending read:', Boolean(this.pendingRead));\n        this.port.data = Buffer.concat([this.port.data, bufferData]);\n        if (this.pendingRead) {\n            process.nextTick(this.pendingRead);\n            this.pendingRead = null;\n        }\n    }\n    async close() {\n        debug(this.serialNumber, 'close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const port = this.port;\n        if (!port) {\n            throw new Error('already closed');\n        }\n        port.openOpt = undefined;\n        // reset data on close\n        port.data = Buffer.alloc(0);\n        debug(this.serialNumber, 'port is closed');\n        this.serialNumber = undefined;\n        this.isOpen = false;\n        if (this.pendingRead) {\n            this.pendingRead(new CanceledError('port is closed'));\n        }\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        debug(this.serialNumber, 'read', length, 'bytes');\n        await resolveNextTick();\n        if (!this.isOpen || !this.port) {\n            throw new CanceledError('Read canceled');\n        }\n        if (this.port.data.length <= 0) {\n            return new Promise((resolve, reject) => {\n                this.pendingRead = err => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    this.read(buffer, offset, length).then(resolve, reject);\n                };\n            });\n        }\n        const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;\n        const data = this.port.data.slice(0, lengthToRead);\n        const bytesRead = data.copy(buffer, offset);\n        this.port.data = this.port.data.slice(lengthToRead);\n        debug(this.serialNumber, 'read', bytesRead, 'bytes');\n        return { bytesRead, buffer };\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (!this.isOpen || !this.port) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        debug(this.serialNumber, 'write', buffer.length, 'bytes');\n        if (this.writeOperation) {\n            throw new Error('Overlapping writes are not supported and should be queued by the serialport object');\n        }\n        this.writeOperation = (async () => {\n            await resolveNextTick();\n            if (!this.isOpen || !this.port) {\n                throw new Error('Write canceled');\n            }\n            const data = (this.lastWrite = Buffer.from(buffer)); // copy\n            if (this.port.record) {\n                this.recording = Buffer.concat([this.recording, data]);\n            }\n            if (this.port.echo) {\n                process.nextTick(() => {\n                    if (this.isOpen) {\n                        this.emitData(data);\n                    }\n                });\n            }\n            this.writeOperation = null;\n            debug(this.serialNumber, 'writing finished');\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (typeof options !== 'object') {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug(this.serialNumber, 'update');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        if (this.port.openOpt) {\n            this.port.openOpt.baudRate = options.baudRate;\n        }\n    }\n    async set(options) {\n        if (typeof options !== 'object') {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug(this.serialNumber, 'set');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n    }\n    async get() {\n        debug(this.serialNumber, 'get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        return {\n            cts: true,\n            dsr: false,\n            dcd: false,\n        };\n    }\n    async getBaudRate() {\n        var _a;\n        debug(this.serialNumber, 'getBaudRate');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {\n            throw new Error('Internal Error');\n        }\n        return {\n            baudRate: this.port.openOpt.baudRate,\n        };\n    }\n    async flush() {\n        debug(this.serialNumber, 'flush');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        this.port.data = Buffer.alloc(0);\n    }\n    async drain() {\n        debug(this.serialNumber, 'drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await resolveNextTick();\n    }\n}\n\nexports.CanceledError = CanceledError;\nexports.MockBinding = MockBinding;\nexports.MockPortBinding = MockPortBinding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZy1tb2NrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBTzs7QUFFbEMscUNBQXFDLDREQUE0RDs7QUFFakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnREFBZ0QsbUlBQW1JO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0hBQXdIO0FBQ3BLLGdCQUFnQixPQUFPO0FBQ3ZCLDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixLQUFLO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3RELHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZy1tb2NrL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZGVidWdGYWN0b3J5ID0gcmVxdWlyZSgnZGVidWcnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBkZWJ1Z0ZhY3RvcnlfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGRlYnVnRmFjdG9yeSk7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSgnc2VyaWFscG9ydC9iaW5kaW5nLW1vY2snKTtcbmxldCBwb3J0cyA9IHt9O1xubGV0IHNlcmlhbE51bWJlciA9IDA7XG5mdW5jdGlvbiByZXNvbHZlTmV4dFRpY2soKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gcHJvY2Vzcy5uZXh0VGljaygoKSA9PiByZXNvbHZlKCkpKTtcbn1cbmNsYXNzIENhbmNlbGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgfVxufVxuY29uc3QgTW9ja0JpbmRpbmcgPSB7XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHBvcnRzID0ge307XG4gICAgICAgIHNlcmlhbE51bWJlciA9IDA7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSBtb2NrIHBvcnRcbiAgICBjcmVhdGVQb3J0KHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzZXJpYWxOdW1iZXIrKztcbiAgICAgICAgY29uc3Qgb3B0V2l0aERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7IGVjaG86IGZhbHNlLCByZWNvcmQ6IGZhbHNlLCBtYW51ZmFjdHVyZXI6ICdUaGUgSjUgUm9ib3RpY3MgQ29tcGFueScsIHZlbmRvcklkOiB1bmRlZmluZWQsIHByb2R1Y3RJZDogdW5kZWZpbmVkLCBtYXhSZWFkU2l6ZTogMTAyNCB9LCBvcHRpb25zKTtcbiAgICAgICAgcG9ydHNbcGF0aF0gPSB7XG4gICAgICAgICAgICBkYXRhOiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgICAgICBlY2hvOiBvcHRXaXRoRGVmYXVsdHMuZWNobyxcbiAgICAgICAgICAgIHJlY29yZDogb3B0V2l0aERlZmF1bHRzLnJlY29yZCxcbiAgICAgICAgICAgIHJlYWR5RGF0YTogb3B0V2l0aERlZmF1bHRzLnJlYWR5RGF0YSxcbiAgICAgICAgICAgIG1heFJlYWRTaXplOiBvcHRXaXRoRGVmYXVsdHMubWF4UmVhZFNpemUsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IG9wdFdpdGhEZWZhdWx0cy5tYW51ZmFjdHVyZXIsXG4gICAgICAgICAgICAgICAgc2VyaWFsTnVtYmVyOiBgJHtzZXJpYWxOdW1iZXJ9YCxcbiAgICAgICAgICAgICAgICBwbnBJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2ZW5kb3JJZDogb3B0V2l0aERlZmF1bHRzLnZlbmRvcklkLFxuICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogb3B0V2l0aERlZmF1bHRzLnByb2R1Y3RJZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGRlYnVnKHNlcmlhbE51bWJlciwgJ2NyZWF0ZWQgcG9ydCcsIEpTT04uc3RyaW5naWZ5KHsgcGF0aCwgb3B0OiBvcHRpb25zIH0pKTtcbiAgICB9LFxuICAgIGFzeW5jIGxpc3QoKSB7XG4gICAgICAgIGRlYnVnKG51bGwsICdsaXN0Jyk7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHBvcnRzKS5tYXAocG9ydCA9PiBwb3J0LmluZm8pO1xuICAgIH0sXG4gICAgYXN5bmMgb3BlbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGF0aFwiIGlzIG5vdCBhIHZhbGlkIHBvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuYmF1ZFJhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmF1ZFJhdGVcIiBpcyBub3QgYSB2YWxpZCBiYXVkUmF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wZW5PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGRhdGFCaXRzOiA4LCBsb2NrOiB0cnVlLCBzdG9wQml0czogMSwgcGFyaXR5OiAnbm9uZScsIHJ0c2N0czogZmFsc2UsIHhvbjogZmFsc2UsIHhvZmY6IGZhbHNlLCB4YW55OiBmYWxzZSwgaHVwY2w6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gb3Blbk9wdGlvbnM7XG4gICAgICAgIGRlYnVnKG51bGwsIGBvcGVuOiBvcGVuaW5nIHBhdGggJHtwYXRofWApO1xuICAgICAgICBjb25zdCBwb3J0ID0gcG9ydHNbcGF0aF07XG4gICAgICAgIGF3YWl0IHJlc29sdmVOZXh0VGljaygpO1xuICAgICAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9ydCBkb2VzIG5vdCBleGlzdCAtIHBsZWFzZSBjYWxsIE1vY2tCaW5kaW5nLmNyZWF0ZVBvcnQoJyR7cGF0aH0nKSBmaXJzdGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbE51bWJlciA9IHBvcnQuaW5mby5zZXJpYWxOdW1iZXI7XG4gICAgICAgIGlmICgoX2EgPSBwb3J0Lm9wZW5PcHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NrKSB7XG4gICAgICAgICAgICBkZWJ1ZyhzZXJpYWxOdW1iZXIsICdvcGVuOiBQb3J0IGlzIGxvY2tlZCBjYW5ub3Qgb3BlbicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIGxvY2tlZCBjYW5ub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKHNlcmlhbE51bWJlciwgYG9wZW46IG9wZW5lZCBwYXRoICR7cGF0aH1gKTtcbiAgICAgICAgcG9ydC5vcGVuT3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3Blbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IE1vY2tQb3J0QmluZGluZyhwb3J0LCBvcGVuT3B0aW9ucyk7XG4gICAgfSxcbn07XG4vKipcbiAqIE1vY2sgYmluZGluZ3MgZm9yIHByZXRlbmQgc2VyaWFscG9ydCBhY2Nlc3NcbiAqL1xuY2xhc3MgTW9ja1BvcnRCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0LCBvcGVuT3B0aW9ucykge1xuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLm9wZW5PcHRpb25zID0gb3Blbk9wdGlvbnM7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdFdyaXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMud3JpdGVPcGVyYXRpb24gPSBudWxsOyAvLyBpbiBmbGlnaHQgcHJvbWlzZSBvciBudWxsXG4gICAgICAgIHRoaXMuc2VyaWFsTnVtYmVyID0gcG9ydC5pbmZvLnNlcmlhbE51bWJlcjtcbiAgICAgICAgaWYgKHBvcnQucmVhZHlEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcG9ydC5yZWFkeURhdGE7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICdlbWl0dGluZyByZWFkeSBkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdERhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRW1pdCBkYXRhIG9uIGEgbW9jayBwb3J0XG4gICAgZW1pdERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBtdXN0IGJlIG9wZW4gdG8gcHJldGVuZCB0byByZWNlaXZlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXJEYXRhID0gQnVmZmVyLmlzQnVmZmVyKGRhdGEpID8gZGF0YSA6IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkZWJ1Zyh0aGlzLnNlcmlhbE51bWJlciwgJ2VtaXR0aW5nIGRhdGEgLSBwZW5kaW5nIHJlYWQ6JywgQm9vbGVhbih0aGlzLnBlbmRpbmdSZWFkKSk7XG4gICAgICAgIHRoaXMucG9ydC5kYXRhID0gQnVmZmVyLmNvbmNhdChbdGhpcy5wb3J0LmRhdGEsIGJ1ZmZlckRhdGFdKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1JlYWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sodGhpcy5wZW5kaW5nUmVhZCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWFkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICdjbG9zZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5wb3J0O1xuICAgICAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBwb3J0Lm9wZW5PcHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHJlc2V0IGRhdGEgb24gY2xvc2VcbiAgICAgICAgcG9ydC5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBkZWJ1Zyh0aGlzLnNlcmlhbE51bWJlciwgJ3BvcnQgaXMgY2xvc2VkJyk7XG4gICAgICAgIHRoaXMuc2VyaWFsTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVhZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVhZChuZXcgQ2FuY2VsZWRFcnJvcigncG9ydCBpcyBjbG9zZWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZChidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgaXMgbm90IGEgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwib2Zmc2V0XCIgaXMgbm90IGFuIGludGVnZXIgZ290IFwiJHtpc05hTihvZmZzZXQpID8gJ05hTicgOiB0eXBlb2Ygb2Zmc2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGlzTmFOKGxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwibGVuZ3RoXCIgaXMgbm90IGFuIGludGVnZXIgZ290IFwiJHtpc05hTihsZW5ndGgpID8gJ05hTicgOiB0eXBlb2YgbGVuZ3RofVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBvZmZzZXQgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGlzIHRvbyBzbWFsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKHRoaXMuc2VyaWFsTnVtYmVyLCAncmVhZCcsIGxlbmd0aCwgJ2J5dGVzJyk7XG4gICAgICAgIGF3YWl0IHJlc29sdmVOZXh0VGljaygpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKCdSZWFkIGNhbmNlbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9ydC5kYXRhLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlYWQgPSBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoVG9SZWFkID0gdGhpcy5wb3J0Lm1heFJlYWRTaXplID4gbGVuZ3RoID8gbGVuZ3RoIDogdGhpcy5wb3J0Lm1heFJlYWRTaXplO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wb3J0LmRhdGEuc2xpY2UoMCwgbGVuZ3RoVG9SZWFkKTtcbiAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5wb3J0LmRhdGEgPSB0aGlzLnBvcnQuZGF0YS5zbGljZShsZW5ndGhUb1JlYWQpO1xuICAgICAgICBkZWJ1Zyh0aGlzLnNlcmlhbE51bWJlciwgJ3JlYWQnLCBieXRlc1JlYWQsICdieXRlcycpO1xuICAgICAgICByZXR1cm4geyBieXRlc1JlYWQsIGJ1ZmZlciB9O1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShidWZmZXIpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBpcyBub3QgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIGRlYnVnKCd3cml0ZScsICdlcnJvciBwb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zyh0aGlzLnNlcmlhbE51bWJlciwgJ3dyaXRlJywgYnVmZmVyLmxlbmd0aCwgJ2J5dGVzJyk7XG4gICAgICAgIGlmICh0aGlzLndyaXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIHdyaXRlcyBhcmUgbm90IHN1cHBvcnRlZCBhbmQgc2hvdWxkIGJlIHF1ZXVlZCBieSB0aGUgc2VyaWFscG9ydCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlT3BlcmF0aW9uID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHJlc29sdmVOZXh0VGljaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5wb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcml0ZSBjYW5jZWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICh0aGlzLmxhc3RXcml0ZSA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcikpOyAvLyBjb3B5XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0LnJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gQnVmZmVyLmNvbmNhdChbdGhpcy5yZWNvcmRpbmcsIGRhdGFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnQuZWNobykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdERhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud3JpdGVPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICd3cml0aW5nIGZpbmlzaGVkJyk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlT3BlcmF0aW9uO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1wib3B0aW9uc1wiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmF1ZFJhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuYmF1ZFJhdGVcIiBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zyh0aGlzLnNlcmlhbE51bWJlciwgJ3VwZGF0ZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlc29sdmVOZXh0VGljaygpO1xuICAgICAgICBpZiAodGhpcy5wb3J0Lm9wZW5PcHQpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydC5vcGVuT3B0LmJhdWRSYXRlID0gb3B0aW9ucy5iYXVkUmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXQob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICdzZXQnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzb2x2ZU5leHRUaWNrKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldCgpIHtcbiAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICdnZXQnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzb2x2ZU5leHRUaWNrKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdHM6IHRydWUsXG4gICAgICAgICAgICBkc3I6IGZhbHNlLFxuICAgICAgICAgICAgZGNkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmF1ZFJhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICdnZXRCYXVkUmF0ZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlc29sdmVOZXh0VGljaygpO1xuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLnBvcnQub3Blbk9wdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJhdWRSYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXVkUmF0ZTogdGhpcy5wb3J0Lm9wZW5PcHQuYmF1ZFJhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBkZWJ1Zyh0aGlzLnNlcmlhbE51bWJlciwgJ2ZsdXNoJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gfHwgIXRoaXMucG9ydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzb2x2ZU5leHRUaWNrKCk7XG4gICAgICAgIHRoaXMucG9ydC5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbiAgICBhc3luYyBkcmFpbigpIHtcbiAgICAgICAgZGVidWcodGhpcy5zZXJpYWxOdW1iZXIsICdkcmFpbicpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndyaXRlT3BlcmF0aW9uO1xuICAgICAgICBhd2FpdCByZXNvbHZlTmV4dFRpY2soKTtcbiAgICB9XG59XG5cbmV4cG9ydHMuQ2FuY2VsZWRFcnJvciA9IENhbmNlbGVkRXJyb3I7XG5leHBvcnRzLk1vY2tCaW5kaW5nID0gTW9ja0JpbmRpbmc7XG5leHBvcnRzLk1vY2tQb3J0QmluZGluZyA9IE1vY2tQb3J0QmluZGluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/binding-mock/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/darwin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/darwin.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DarwinPortBinding = exports.DarwinBinding = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst load_bindings_1 = __webpack_require__(/*! ./load-bindings */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/load-bindings.js\");\nconst poller_1 = __webpack_require__(/*! ./poller */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/poller.js\");\nconst unix_read_1 = __webpack_require__(/*! ./unix-read */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-read.js\");\nconst unix_write_1 = __webpack_require__(/*! ./unix-write */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-write.js\");\nconst debug = (0, debug_1.default)('serialport/bindings-cpp');\nexports.DarwinBinding = {\n    list() {\n        debug('list');\n        return (0, load_bindings_1.asyncList)();\n    },\n    async open(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        debug('open');\n        const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);\n        return new DarwinPortBinding(fd, openOptions);\n    },\n};\n/**\n * The Darwin binding layer for OSX\n */\nclass DarwinPortBinding {\n    constructor(fd, options) {\n        this.fd = fd;\n        this.openOptions = options;\n        this.poller = new poller_1.Poller(fd);\n        this.writeOperation = null;\n    }\n    get isOpen() {\n        return this.fd !== null;\n    }\n    async close() {\n        debug('close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const fd = this.fd;\n        this.poller.stop();\n        this.poller.destroy();\n        this.fd = null;\n        await (0, load_bindings_1.asyncClose)(fd);\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        debug('read');\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, unix_read_1.unixRead)({ binding: this, buffer, offset, length });\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        debug('write', buffer.length, 'bytes');\n        if (!this.isOpen) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        this.writeOperation = (async () => {\n            if (buffer.length === 0) {\n                return;\n            }\n            await (0, unix_write_1.unixWrite)({ binding: this, buffer });\n            this.writeOperation = null;\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug('update');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncUpdate)(this.fd, options);\n    }\n    async set(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug('set', options);\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncSet)(this.fd, options);\n    }\n    async get() {\n        debug('get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGet)(this.fd);\n    }\n    async getBaudRate() {\n        debug('getBaudRate');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        throw new Error('getBaudRate is not implemented on darwin');\n    }\n    async flush() {\n        debug('flush');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncFlush)(this.fd);\n    }\n    async drain() {\n        debug('drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await (0, load_bindings_1.asyncDrain)(this.fd);\n    }\n}\nexports.DarwinPortBinding = DarwinPortBinding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvZGFyd2luLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcscUJBQXFCO0FBQ2pELGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLDRGQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyxvRkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBYztBQUMzQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywySUFBMkk7QUFDdkw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvZGFyd2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXJ3aW5Qb3J0QmluZGluZyA9IGV4cG9ydHMuRGFyd2luQmluZGluZyA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGxvYWRfYmluZGluZ3NfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmluZGluZ3NcIik7XG5jb25zdCBwb2xsZXJfMSA9IHJlcXVpcmUoXCIuL3BvbGxlclwiKTtcbmNvbnN0IHVuaXhfcmVhZF8xID0gcmVxdWlyZShcIi4vdW5peC1yZWFkXCIpO1xuY29uc3QgdW5peF93cml0ZV8xID0gcmVxdWlyZShcIi4vdW5peC13cml0ZVwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ3NlcmlhbHBvcnQvYmluZGluZ3MtY3BwJyk7XG5leHBvcnRzLkRhcndpbkJpbmRpbmcgPSB7XG4gICAgbGlzdCgpIHtcbiAgICAgICAgZGVidWcoJ2xpc3QnKTtcbiAgICAgICAgcmV0dXJuICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNMaXN0KSgpO1xuICAgIH0sXG4gICAgYXN5bmMgb3BlbihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zXCIgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhdGhcIiBpcyBub3QgYSB2YWxpZCBwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmJhdWRSYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJhdWRSYXRlXCIgaXMgbm90IGEgdmFsaWQgYmF1ZFJhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnb3BlbicpO1xuICAgICAgICBjb25zdCBvcGVuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB2bWluOiAxLCB2dGltZTogMCwgZGF0YUJpdHM6IDgsIGxvY2s6IHRydWUsIHN0b3BCaXRzOiAxLCBwYXJpdHk6ICdub25lJywgcnRzY3RzOiBmYWxzZSwgeG9uOiBmYWxzZSwgeG9mZjogZmFsc2UsIHhhbnk6IGZhbHNlLCBodXBjbDogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmQgPSBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jT3Blbikob3Blbk9wdGlvbnMucGF0aCwgb3Blbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IERhcndpblBvcnRCaW5kaW5nKGZkLCBvcGVuT3B0aW9ucyk7XG4gICAgfSxcbn07XG4vKipcbiAqIFRoZSBEYXJ3aW4gYmluZGluZyBsYXllciBmb3IgT1NYXG4gKi9cbmNsYXNzIERhcndpblBvcnRCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihmZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgICAgIHRoaXMub3Blbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBvbGxlciA9IG5ldyBwb2xsZXJfMS5Qb2xsZXIoZmQpO1xuICAgICAgICB0aGlzLndyaXRlT3BlcmF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmQgIT09IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmQgPSB0aGlzLmZkO1xuICAgICAgICB0aGlzLnBvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucG9sbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5mZCA9IG51bGw7XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNDbG9zZSkoZmQpO1xuICAgIH1cbiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBpcyBub3QgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJvZmZzZXRcIiBpcyBub3QgYW4gaW50ZWdlciBnb3QgXCIke2lzTmFOKG9mZnNldCkgPyAnTmFOJyA6IHR5cGVvZiBvZmZzZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJsZW5ndGhcIiBpcyBub3QgYW4gaW50ZWdlciBnb3QgXCIke2lzTmFOKGxlbmd0aCkgPyAnTmFOJyA6IHR5cGVvZiBsZW5ndGh9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygncmVhZCcpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgaXMgdG9vIHNtYWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1bml4X3JlYWRfMS51bml4UmVhZCkoeyBiaW5kaW5nOiB0aGlzLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShidWZmZXIpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBpcyBub3QgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnd3JpdGUnLCBidWZmZXIubGVuZ3RoLCAnYnl0ZXMnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgZGVidWcoJ3dyaXRlJywgJ2Vycm9yIHBvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVPcGVyYXRpb24gPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdW5peF93cml0ZV8xLnVuaXhXcml0ZSkoeyBiaW5kaW5nOiB0aGlzLCBidWZmZXIgfSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlT3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVPcGVyYXRpb247XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhdWRSYXRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmJhdWRSYXRlXCIgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3VwZGF0ZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jVXBkYXRlKSh0aGlzLmZkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3NldCcsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jU2V0KSh0aGlzLmZkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KCkge1xuICAgICAgICBkZWJ1ZygnZ2V0Jyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jR2V0KSh0aGlzLmZkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmF1ZFJhdGUoKSB7XG4gICAgICAgIGRlYnVnKCdnZXRCYXVkUmF0ZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEJhdWRSYXRlIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBkYXJ3aW4nKTtcbiAgICB9XG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGRlYnVnKCdmbHVzaCcpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jRmx1c2gpKHRoaXMuZmQpO1xuICAgIH1cbiAgICBhc3luYyBkcmFpbigpIHtcbiAgICAgICAgZGVidWcoJ2RyYWluJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVPcGVyYXRpb247XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNEcmFpbikodGhpcy5mZCk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXJ3aW5Qb3J0QmluZGluZyA9IERhcndpblBvcnRCaW5kaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/darwin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/errors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BindingsError = void 0;\nclass BindingsError extends Error {\n    constructor(message, { canceled = false } = {}) {\n        super(message);\n        this.canceled = canceled;\n    }\n}\nexports.BindingsError = BindingsError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBLDJCQUEyQixtQkFBbUIsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9kaXN0L2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmluZGluZ3NFcnJvciA9IHZvaWQgMDtcbmNsYXNzIEJpbmRpbmdzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgeyBjYW5jZWxlZCA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IGNhbmNlbGVkO1xuICAgIH1cbn1cbmV4cG9ydHMuQmluZGluZ3NFcnJvciA9IEJpbmRpbmdzRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.autoDetect = autoDetect;\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst darwin_1 = __webpack_require__(/*! ./darwin */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/darwin.js\");\nconst linux_1 = __webpack_require__(/*! ./linux */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux.js\");\nconst win32_1 = __webpack_require__(/*! ./win32 */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32.js\");\nconst debug = (0, debug_1.default)('serialport/bindings-cpp');\n__exportStar(__webpack_require__(/*! @serialport/bindings-interface */ \"(rsc)/./node_modules/@serialport/bindings-interface/dist/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./darwin */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/darwin.js\"), exports);\n__exportStar(__webpack_require__(/*! ./linux */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux.js\"), exports);\n__exportStar(__webpack_require__(/*! ./win32 */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32.js\"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/errors.js\"), exports);\n/**\n * This is an auto detected binding for your current platform\n */\nfunction autoDetect() {\n    switch (process.platform) {\n        case 'win32':\n            debug('loading WindowsBinding');\n            return win32_1.WindowsBinding;\n        case 'darwin':\n            debug('loading DarwinBinding');\n            return darwin_1.DarwinBinding;\n        default:\n            debug('loading LinuxBinding');\n            return linux_1.LinuxBinding;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBUztBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDckQsYUFBYSxtQkFBTyxDQUFDLDhFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw0RUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsNEVBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDhFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXV0b0RldGVjdCA9IGF1dG9EZXRlY3Q7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzICovXG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkYXJ3aW5fMSA9IHJlcXVpcmUoXCIuL2RhcndpblwiKTtcbmNvbnN0IGxpbnV4XzEgPSByZXF1aXJlKFwiLi9saW51eFwiKTtcbmNvbnN0IHdpbjMyXzEgPSByZXF1aXJlKFwiLi93aW4zMlwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ3NlcmlhbHBvcnQvYmluZGluZ3MtY3BwJyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkBzZXJpYWxwb3J0L2JpbmRpbmdzLWludGVyZmFjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGFyd2luXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saW51eFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2luMzJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFRoaXMgaXMgYW4gYXV0byBkZXRlY3RlZCBiaW5kaW5nIGZvciB5b3VyIGN1cnJlbnQgcGxhdGZvcm1cbiAqL1xuZnVuY3Rpb24gYXV0b0RldGVjdCgpIHtcbiAgICBzd2l0Y2ggKHByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICAgICAgY2FzZSAnd2luMzInOlxuICAgICAgICAgICAgZGVidWcoJ2xvYWRpbmcgV2luZG93c0JpbmRpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB3aW4zMl8xLldpbmRvd3NCaW5kaW5nO1xuICAgICAgICBjYXNlICdkYXJ3aW4nOlxuICAgICAgICAgICAgZGVidWcoJ2xvYWRpbmcgRGFyd2luQmluZGluZycpO1xuICAgICAgICAgICAgcmV0dXJuIGRhcndpbl8xLkRhcndpbkJpbmRpbmc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBkZWJ1ZygnbG9hZGluZyBMaW51eEJpbmRpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBsaW51eF8xLkxpbnV4QmluZGluZztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux-list.js":
/*!******************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/linux-list.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.linuxList = linuxList;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst parser_readline_1 = __webpack_require__(/*! @serialport/parser-readline */ \"(rsc)/./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-readline/dist/index.js\");\n// get only serial port names\nfunction checkPathOfDevice(path) {\n    return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path) && path;\n}\nfunction propName(name) {\n    return {\n        DEVNAME: 'path',\n        ID_VENDOR_ENC: 'manufacturer',\n        ID_SERIAL_SHORT: 'serialNumber',\n        ID_VENDOR_ID: 'vendorId',\n        ID_MODEL_ID: 'productId',\n        DEVLINKS: 'pnpId',\n        /**\n        * Workaround for systemd defect\n        * see https://github.com/serialport/bindings-cpp/issues/115\n        */\n        ID_USB_VENDOR_ENC: 'manufacturer',\n        ID_USB_SERIAL_SHORT: 'serialNumber',\n        ID_USB_VENDOR_ID: 'vendorId',\n        ID_USB_MODEL_ID: 'productId',\n        // End of workaround\n    }[name.toUpperCase()];\n}\nfunction decodeHexEscape(str) {\n    return str.replace(/\\\\x([a-fA-F0-9]{2})/g, (a, b) => {\n        return String.fromCharCode(parseInt(b, 16));\n    });\n}\nfunction propVal(name, val) {\n    if (name === 'pnpId') {\n        const match = val.match(/\\/by-id\\/([^\\s]+)/);\n        return (match === null || match === void 0 ? void 0 : match[1]) || undefined;\n    }\n    if (name === 'manufacturer') {\n        return decodeHexEscape(val);\n    }\n    if (/^0x/.test(val)) {\n        return val.substr(2);\n    }\n    return val;\n}\nfunction linuxList(spawnCmd = child_process_1.spawn) {\n    const ports = [];\n    const udevadm = spawnCmd('udevadm', ['info', '-e']);\n    const lines = udevadm.stdout.pipe(new parser_readline_1.ReadlineParser());\n    let skipPort = false;\n    let port = {\n        path: '',\n        manufacturer: undefined,\n        serialNumber: undefined,\n        pnpId: undefined,\n        locationId: undefined,\n        vendorId: undefined,\n        productId: undefined,\n    };\n    lines.on('data', (line) => {\n        const lineType = line.slice(0, 1);\n        const data = line.slice(3);\n        // new port entry\n        if (lineType === 'P') {\n            port = {\n                path: '',\n                manufacturer: undefined,\n                serialNumber: undefined,\n                pnpId: undefined,\n                locationId: undefined,\n                vendorId: undefined,\n                productId: undefined,\n            };\n            skipPort = false;\n            return;\n        }\n        if (skipPort) {\n            return;\n        }\n        // Check dev name and save port if it matches flag to skip the rest of the data if not\n        if (lineType === 'N') {\n            if (checkPathOfDevice(data)) {\n                ports.push(port);\n            }\n            else {\n                skipPort = true;\n            }\n            return;\n        }\n        // parse data about each port\n        if (lineType === 'E') {\n            const keyValue = data.match(/^(.+)=(.*)/);\n            if (!keyValue) {\n                return;\n            }\n            const key = propName(keyValue[1]);\n            if (!key) {\n                return;\n            }\n            port[key] = propVal(key, keyValue[2]);\n        }\n    });\n    return new Promise((resolve, reject) => {\n        udevadm.on('close', (code) => {\n            if (code) {\n                reject(new Error(`Error listing ports udevadm exited with error code: ${code}`));\n            }\n        });\n        udevadm.on('error', reject);\n        lines.on('error', reject);\n        lines.on('finish', () => resolve(ports));\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvbGludXgtbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsd0JBQXdCLG1CQUFPLENBQUMsb0NBQWU7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMseUlBQTZCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLEtBQUs7QUFDN0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvbGludXgtbGlzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubGludXhMaXN0ID0gbGludXhMaXN0O1xuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG5jb25zdCBwYXJzZXJfcmVhZGxpbmVfMSA9IHJlcXVpcmUoXCJAc2VyaWFscG9ydC9wYXJzZXItcmVhZGxpbmVcIik7XG4vLyBnZXQgb25seSBzZXJpYWwgcG9ydCBuYW1lc1xuZnVuY3Rpb24gY2hlY2tQYXRoT2ZEZXZpY2UocGF0aCkge1xuICAgIHJldHVybiAvKHR0eShTfFdDSHxBQ018VVNCfEFNQXxNRkR8T3xYUlVTQil8cmZjb21tKS8udGVzdChwYXRoKSAmJiBwYXRoO1xufVxuZnVuY3Rpb24gcHJvcE5hbWUobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIERFVk5BTUU6ICdwYXRoJyxcbiAgICAgICAgSURfVkVORE9SX0VOQzogJ21hbnVmYWN0dXJlcicsXG4gICAgICAgIElEX1NFUklBTF9TSE9SVDogJ3NlcmlhbE51bWJlcicsXG4gICAgICAgIElEX1ZFTkRPUl9JRDogJ3ZlbmRvcklkJyxcbiAgICAgICAgSURfTU9ERUxfSUQ6ICdwcm9kdWN0SWQnLFxuICAgICAgICBERVZMSU5LUzogJ3BucElkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICogV29ya2Fyb3VuZCBmb3Igc3lzdGVtZCBkZWZlY3RcbiAgICAgICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2lzc3Vlcy8xMTVcbiAgICAgICAgKi9cbiAgICAgICAgSURfVVNCX1ZFTkRPUl9FTkM6ICdtYW51ZmFjdHVyZXInLFxuICAgICAgICBJRF9VU0JfU0VSSUFMX1NIT1JUOiAnc2VyaWFsTnVtYmVyJyxcbiAgICAgICAgSURfVVNCX1ZFTkRPUl9JRDogJ3ZlbmRvcklkJyxcbiAgICAgICAgSURfVVNCX01PREVMX0lEOiAncHJvZHVjdElkJyxcbiAgICAgICAgLy8gRW5kIG9mIHdvcmthcm91bmRcbiAgICB9W25hbWUudG9VcHBlckNhc2UoKV07XG59XG5mdW5jdGlvbiBkZWNvZGVIZXhFc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxceChbYS1mQS1GMC05XXsyfSkvZywgKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYiwgMTYpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByb3BWYWwobmFtZSwgdmFsKSB7XG4gICAgaWYgKG5hbWUgPT09ICdwbnBJZCcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWwubWF0Y2goL1xcL2J5LWlkXFwvKFteXFxzXSspLyk7XG4gICAgICAgIHJldHVybiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnbWFudWZhY3R1cmVyJykge1xuICAgICAgICByZXR1cm4gZGVjb2RlSGV4RXNjYXBlKHZhbCk7XG4gICAgfVxuICAgIGlmICgvXjB4Ly50ZXN0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zdWJzdHIoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBsaW51eExpc3Qoc3Bhd25DbWQgPSBjaGlsZF9wcm9jZXNzXzEuc3Bhd24pIHtcbiAgICBjb25zdCBwb3J0cyA9IFtdO1xuICAgIGNvbnN0IHVkZXZhZG0gPSBzcGF3bkNtZCgndWRldmFkbScsIFsnaW5mbycsICctZSddKTtcbiAgICBjb25zdCBsaW5lcyA9IHVkZXZhZG0uc3Rkb3V0LnBpcGUobmV3IHBhcnNlcl9yZWFkbGluZV8xLlJlYWRsaW5lUGFyc2VyKCkpO1xuICAgIGxldCBza2lwUG9ydCA9IGZhbHNlO1xuICAgIGxldCBwb3J0ID0ge1xuICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgbWFudWZhY3R1cmVyOiB1bmRlZmluZWQsXG4gICAgICAgIHNlcmlhbE51bWJlcjogdW5kZWZpbmVkLFxuICAgICAgICBwbnBJZDogdW5kZWZpbmVkLFxuICAgICAgICBsb2NhdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIHZlbmRvcklkOiB1bmRlZmluZWQsXG4gICAgICAgIHByb2R1Y3RJZDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgbGluZXMub24oJ2RhdGEnLCAobGluZSkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lVHlwZSA9IGxpbmUuc2xpY2UoMCwgMSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDMpO1xuICAgICAgICAvLyBuZXcgcG9ydCBlbnRyeVxuICAgICAgICBpZiAobGluZVR5cGUgPT09ICdQJykge1xuICAgICAgICAgICAgcG9ydCA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZXJpYWxOdW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwbnBJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2ZW5kb3JJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNraXBQb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBQb3J0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZGV2IG5hbWUgYW5kIHNhdmUgcG9ydCBpZiBpdCBtYXRjaGVzIGZsYWcgdG8gc2tpcCB0aGUgcmVzdCBvZiB0aGUgZGF0YSBpZiBub3RcbiAgICAgICAgaWYgKGxpbmVUeXBlID09PSAnTicpIHtcbiAgICAgICAgICAgIGlmIChjaGVja1BhdGhPZkRldmljZShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHBvcnRzLnB1c2gocG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwUG9ydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFyc2UgZGF0YSBhYm91dCBlYWNoIHBvcnRcbiAgICAgICAgaWYgKGxpbmVUeXBlID09PSAnRScpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlID0gZGF0YS5tYXRjaCgvXiguKyk9KC4qKS8pO1xuICAgICAgICAgICAgaWYgKCFrZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BOYW1lKGtleVZhbHVlWzFdKTtcbiAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9ydFtrZXldID0gcHJvcFZhbChrZXksIGtleVZhbHVlWzJdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHVkZXZhZG0ub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRXJyb3IgbGlzdGluZyBwb3J0cyB1ZGV2YWRtIGV4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICR7Y29kZX1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1ZGV2YWRtLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIGxpbmVzLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIGxpbmVzLm9uKCdmaW5pc2gnLCAoKSA9PiByZXNvbHZlKHBvcnRzKSk7XG4gICAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux-list.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux.js":
/*!*************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/linux.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinuxPortBinding = exports.LinuxBinding = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst linux_list_1 = __webpack_require__(/*! ./linux-list */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux-list.js\");\nconst poller_1 = __webpack_require__(/*! ./poller */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/poller.js\");\nconst unix_read_1 = __webpack_require__(/*! ./unix-read */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-read.js\");\nconst unix_write_1 = __webpack_require__(/*! ./unix-write */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-write.js\");\nconst load_bindings_1 = __webpack_require__(/*! ./load-bindings */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/load-bindings.js\");\nconst debug = (0, debug_1.default)('serialport/bindings-cpp');\nexports.LinuxBinding = {\n    list() {\n        debug('list');\n        return (0, linux_list_1.linuxList)();\n    },\n    async open(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        debug('open');\n        const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);\n        this.fd = fd;\n        return new LinuxPortBinding(fd, openOptions);\n    },\n};\n/**\n * The linux binding layer\n */\nclass LinuxPortBinding {\n    constructor(fd, openOptions) {\n        this.fd = fd;\n        this.openOptions = openOptions;\n        this.poller = new poller_1.Poller(fd);\n        this.writeOperation = null;\n    }\n    get isOpen() {\n        return this.fd !== null;\n    }\n    async close() {\n        debug('close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const fd = this.fd;\n        this.poller.stop();\n        this.poller.destroy();\n        this.fd = null;\n        await (0, load_bindings_1.asyncClose)(fd);\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        debug('read');\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, unix_read_1.unixRead)({ binding: this, buffer, offset, length });\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        debug('write', buffer.length, 'bytes');\n        if (!this.isOpen) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        this.writeOperation = (async () => {\n            if (buffer.length === 0) {\n                return;\n            }\n            await (0, unix_write_1.unixWrite)({ binding: this, buffer });\n            this.writeOperation = null;\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug('update');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncUpdate)(this.fd, options);\n    }\n    async set(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug('set');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncSet)(this.fd, options);\n    }\n    async get() {\n        debug('get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGet)(this.fd);\n    }\n    async getBaudRate() {\n        debug('getBaudRate');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);\n    }\n    async flush() {\n        debug('flush');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncFlush)(this.fd);\n    }\n    async drain() {\n        debug('drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await (0, load_bindings_1.asyncDrain)(this.fd);\n    }\n}\nexports.LinuxPortBinding = LinuxPortBinding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvbGludXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxvQkFBb0I7QUFDL0MsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWM7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVU7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWM7QUFDM0Msd0JBQXdCLG1CQUFPLENBQUMsNEZBQWlCO0FBQ2pEO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJJQUEySTtBQUN2TDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBO0FBQ0EsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9kaXN0L2xpbnV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaW51eFBvcnRCaW5kaW5nID0gZXhwb3J0cy5MaW51eEJpbmRpbmcgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBsaW51eF9saXN0XzEgPSByZXF1aXJlKFwiLi9saW51eC1saXN0XCIpO1xuY29uc3QgcG9sbGVyXzEgPSByZXF1aXJlKFwiLi9wb2xsZXJcIik7XG5jb25zdCB1bml4X3JlYWRfMSA9IHJlcXVpcmUoXCIuL3VuaXgtcmVhZFwiKTtcbmNvbnN0IHVuaXhfd3JpdGVfMSA9IHJlcXVpcmUoXCIuL3VuaXgtd3JpdGVcIik7XG5jb25zdCBsb2FkX2JpbmRpbmdzXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJpbmRpbmdzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnc2VyaWFscG9ydC9iaW5kaW5ncy1jcHAnKTtcbmV4cG9ydHMuTGludXhCaW5kaW5nID0ge1xuICAgIGxpc3QoKSB7XG4gICAgICAgIGRlYnVnKCdsaXN0Jyk7XG4gICAgICAgIHJldHVybiAoMCwgbGludXhfbGlzdF8xLmxpbnV4TGlzdCkoKTtcbiAgICB9LFxuICAgIGFzeW5jIG9wZW4ob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9uc1wiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXRoXCIgaXMgbm90IGEgdmFsaWQgcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5iYXVkUmF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJiYXVkUmF0ZVwiIGlzIG5vdCBhIHZhbGlkIGJhdWRSYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ29wZW4nKTtcbiAgICAgICAgY29uc3Qgb3Blbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdm1pbjogMSwgdnRpbWU6IDAsIGRhdGFCaXRzOiA4LCBsb2NrOiB0cnVlLCBzdG9wQml0czogMSwgcGFyaXR5OiAnbm9uZScsIHJ0c2N0czogZmFsc2UsIHhvbjogZmFsc2UsIHhvZmY6IGZhbHNlLCB4YW55OiBmYWxzZSwgaHVwY2w6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZkID0gYXdhaXQgKDAsIGxvYWRfYmluZGluZ3NfMS5hc3luY09wZW4pKG9wZW5PcHRpb25zLnBhdGgsIG9wZW5PcHRpb25zKTtcbiAgICAgICAgdGhpcy5mZCA9IGZkO1xuICAgICAgICByZXR1cm4gbmV3IExpbnV4UG9ydEJpbmRpbmcoZmQsIG9wZW5PcHRpb25zKTtcbiAgICB9LFxufTtcbi8qKlxuICogVGhlIGxpbnV4IGJpbmRpbmcgbGF5ZXJcbiAqL1xuY2xhc3MgTGludXhQb3J0QmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmQsIG9wZW5PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZmQgPSBmZDtcbiAgICAgICAgdGhpcy5vcGVuT3B0aW9ucyA9IG9wZW5PcHRpb25zO1xuICAgICAgICB0aGlzLnBvbGxlciA9IG5ldyBwb2xsZXJfMS5Qb2xsZXIoZmQpO1xuICAgICAgICB0aGlzLndyaXRlT3BlcmF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmQgIT09IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmQgPSB0aGlzLmZkO1xuICAgICAgICB0aGlzLnBvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucG9sbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5mZCA9IG51bGw7XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNDbG9zZSkoZmQpO1xuICAgIH1cbiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBpcyBub3QgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJvZmZzZXRcIiBpcyBub3QgYW4gaW50ZWdlciBnb3QgXCIke2lzTmFOKG9mZnNldCkgPyAnTmFOJyA6IHR5cGVvZiBvZmZzZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJsZW5ndGhcIiBpcyBub3QgYW4gaW50ZWdlciBnb3QgXCIke2lzTmFOKGxlbmd0aCkgPyAnTmFOJyA6IHR5cGVvZiBsZW5ndGh9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygncmVhZCcpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgaXMgdG9vIHNtYWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1bml4X3JlYWRfMS51bml4UmVhZCkoeyBiaW5kaW5nOiB0aGlzLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShidWZmZXIpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBpcyBub3QgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnd3JpdGUnLCBidWZmZXIubGVuZ3RoLCAnYnl0ZXMnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgZGVidWcoJ3dyaXRlJywgJ2Vycm9yIHBvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVPcGVyYXRpb24gPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdW5peF93cml0ZV8xLnVuaXhXcml0ZSkoeyBiaW5kaW5nOiB0aGlzLCBidWZmZXIgfSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlT3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVPcGVyYXRpb247XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhdWRSYXRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmJhdWRSYXRlXCIgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3VwZGF0ZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jVXBkYXRlKSh0aGlzLmZkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3NldCcpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jU2V0KSh0aGlzLmZkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KCkge1xuICAgICAgICBkZWJ1ZygnZ2V0Jyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jR2V0KSh0aGlzLmZkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmF1ZFJhdGUoKSB7XG4gICAgICAgIGRlYnVnKCdnZXRCYXVkUmF0ZScpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGxvYWRfYmluZGluZ3NfMS5hc3luY0dldEJhdWRSYXRlKSh0aGlzLmZkKTtcbiAgICB9XG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGRlYnVnKCdmbHVzaCcpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jRmx1c2gpKHRoaXMuZmQpO1xuICAgIH1cbiAgICBhc3luYyBkcmFpbigpIHtcbiAgICAgICAgZGVidWcoJ2RyYWluJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVPcGVyYXRpb247XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNEcmFpbikodGhpcy5mZCk7XG4gICAgfVxufVxuZXhwb3J0cy5MaW51eFBvcnRCaW5kaW5nID0gTGludXhQb3J0QmluZGluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/linux.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/load-bindings.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/load-bindings.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asyncWrite = exports.asyncRead = exports.asyncUpdate = exports.asyncSet = exports.asyncOpen = exports.asyncList = exports.asyncGetBaudRate = exports.asyncGet = exports.asyncFlush = exports.asyncDrain = exports.asyncClose = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst serialport_bindings_1 = __webpack_require__(/*! ./serialport-bindings */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/serialport-bindings.js\");\nexports.asyncClose = serialport_bindings_1.binding.close ? (0, util_1.promisify)(serialport_bindings_1.binding.close) : async () => { throw new Error('\"binding.close\" Method not implemented'); };\nexports.asyncDrain = serialport_bindings_1.binding.drain ? (0, util_1.promisify)(serialport_bindings_1.binding.drain) : async () => { throw new Error('\"binding.drain\" Method not implemented'); };\nexports.asyncFlush = serialport_bindings_1.binding.flush ? (0, util_1.promisify)(serialport_bindings_1.binding.flush) : async () => { throw new Error('\"binding.flush\" Method not implemented'); };\nexports.asyncGet = serialport_bindings_1.binding.get ? (0, util_1.promisify)(serialport_bindings_1.binding.get) : async () => { throw new Error('\"binding.get\" Method not implemented'); };\nexports.asyncGetBaudRate = serialport_bindings_1.binding.getBaudRate ? (0, util_1.promisify)(serialport_bindings_1.binding.getBaudRate) : async () => { throw new Error('\"binding.getBaudRate\" Method not implemented'); };\nexports.asyncList = serialport_bindings_1.binding.list ? (0, util_1.promisify)(serialport_bindings_1.binding.list) : async () => { throw new Error('\"binding.list\" Method not implemented'); };\nexports.asyncOpen = serialport_bindings_1.binding.open ? (0, util_1.promisify)(serialport_bindings_1.binding.open) : async () => { throw new Error('\"binding.open\" Method not implemented'); };\nexports.asyncSet = serialport_bindings_1.binding.set ? (0, util_1.promisify)(serialport_bindings_1.binding.set) : async () => { throw new Error('\"binding.set\" Method not implemented'); };\nexports.asyncUpdate = serialport_bindings_1.binding.update ? (0, util_1.promisify)(serialport_bindings_1.binding.update) : async () => { throw new Error('\"binding.update\" Method not implemented'); };\nexports.asyncRead = serialport_bindings_1.binding.read ? (0, util_1.promisify)(serialport_bindings_1.binding.read) : async () => { throw new Error('\"binding.read\" Method not implemented'); };\nexports.asyncWrite = serialport_bindings_1.binding.write ? (0, util_1.promisify)(serialport_bindings_1.binding.write) : async () => { throw new Error('\"binding.write\" Method not implemented'); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvbG9hZC1iaW5kaW5ncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDcE8sZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLDhCQUE4QixtQkFBTyxDQUFDLHdHQUF1QjtBQUM3RCxrQkFBa0Isb0hBQW9IO0FBQ3RJLGtCQUFrQixvSEFBb0g7QUFDdEksa0JBQWtCLG9IQUFvSDtBQUN0SSxnQkFBZ0IsZ0hBQWdIO0FBQ2hJLHdCQUF3QixnSUFBZ0k7QUFDeEosaUJBQWlCLGtIQUFrSDtBQUNuSSxpQkFBaUIsa0hBQWtIO0FBQ25JLGdCQUFnQixnSEFBZ0g7QUFDaEksbUJBQW1CLHNIQUFzSDtBQUN6SSxpQkFBaUIsa0hBQWtIO0FBQ25JLGtCQUFrQixvSEFBb0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9iaW5kaW5ncy1jcHAvZGlzdC9sb2FkLWJpbmRpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3luY1dyaXRlID0gZXhwb3J0cy5hc3luY1JlYWQgPSBleHBvcnRzLmFzeW5jVXBkYXRlID0gZXhwb3J0cy5hc3luY1NldCA9IGV4cG9ydHMuYXN5bmNPcGVuID0gZXhwb3J0cy5hc3luY0xpc3QgPSBleHBvcnRzLmFzeW5jR2V0QmF1ZFJhdGUgPSBleHBvcnRzLmFzeW5jR2V0ID0gZXhwb3J0cy5hc3luY0ZsdXNoID0gZXhwb3J0cy5hc3luY0RyYWluID0gZXhwb3J0cy5hc3luY0Nsb3NlID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzZXJpYWxwb3J0X2JpbmRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxwb3J0LWJpbmRpbmdzXCIpO1xuZXhwb3J0cy5hc3luY0Nsb3NlID0gc2VyaWFscG9ydF9iaW5kaW5nc18xLmJpbmRpbmcuY2xvc2UgPyAoMCwgdXRpbF8xLnByb21pc2lmeSkoc2VyaWFscG9ydF9iaW5kaW5nc18xLmJpbmRpbmcuY2xvc2UpIDogYXN5bmMgKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ1wiYmluZGluZy5jbG9zZVwiIE1ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTsgfTtcbmV4cG9ydHMuYXN5bmNEcmFpbiA9IHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLmRyYWluID8gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLmRyYWluKSA6IGFzeW5jICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdcImJpbmRpbmcuZHJhaW5cIiBNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7IH07XG5leHBvcnRzLmFzeW5jRmx1c2ggPSBzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5mbHVzaCA/ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5mbHVzaCkgOiBhc3luYyAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignXCJiaW5kaW5nLmZsdXNoXCIgTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpOyB9O1xuZXhwb3J0cy5hc3luY0dldCA9IHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLmdldCA/ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5nZXQpIDogYXN5bmMgKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ1wiYmluZGluZy5nZXRcIiBNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7IH07XG5leHBvcnRzLmFzeW5jR2V0QmF1ZFJhdGUgPSBzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5nZXRCYXVkUmF0ZSA/ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5nZXRCYXVkUmF0ZSkgOiBhc3luYyAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignXCJiaW5kaW5nLmdldEJhdWRSYXRlXCIgTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpOyB9O1xuZXhwb3J0cy5hc3luY0xpc3QgPSBzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5saXN0ID8gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLmxpc3QpIDogYXN5bmMgKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ1wiYmluZGluZy5saXN0XCIgTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpOyB9O1xuZXhwb3J0cy5hc3luY09wZW4gPSBzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5vcGVuID8gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLm9wZW4pIDogYXN5bmMgKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ1wiYmluZGluZy5vcGVuXCIgTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpOyB9O1xuZXhwb3J0cy5hc3luY1NldCA9IHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLnNldCA/ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5zZXQpIDogYXN5bmMgKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ1wiYmluZGluZy5zZXRcIiBNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7IH07XG5leHBvcnRzLmFzeW5jVXBkYXRlID0gc2VyaWFscG9ydF9iaW5kaW5nc18xLmJpbmRpbmcudXBkYXRlID8gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLnVwZGF0ZSkgOiBhc3luYyAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignXCJiaW5kaW5nLnVwZGF0ZVwiIE1ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTsgfTtcbmV4cG9ydHMuYXN5bmNSZWFkID0gc2VyaWFscG9ydF9iaW5kaW5nc18xLmJpbmRpbmcucmVhZCA/ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZy5yZWFkKSA6IGFzeW5jICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdcImJpbmRpbmcucmVhZFwiIE1ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTsgfTtcbmV4cG9ydHMuYXN5bmNXcml0ZSA9IHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLndyaXRlID8gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHNlcmlhbHBvcnRfYmluZGluZ3NfMS5iaW5kaW5nLndyaXRlKSA6IGFzeW5jICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdcImJpbmRpbmcud3JpdGVcIiBNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/load-bindings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/poller.js":
/*!**************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/poller.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Poller = exports.EVENTS = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/errors.js\");\nconst serialport_bindings_1 = __webpack_require__(/*! ./serialport-bindings */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/serialport-bindings.js\");\nconst { Poller: PollerBindings } = serialport_bindings_1.binding;\nconst logger = (0, debug_1.default)('serialport/bindings-cpp/poller');\nexports.EVENTS = {\n    UV_READABLE: 0b0001,\n    UV_WRITABLE: 0b0010,\n    UV_DISCONNECT: 0b0100,\n};\nfunction handleEvent(error, eventFlag) {\n    if (error) {\n        logger('error', error);\n        this.emit('readable', error);\n        this.emit('writable', error);\n        this.emit('disconnect', error);\n        return;\n    }\n    if (eventFlag & exports.EVENTS.UV_READABLE) {\n        logger('received \"readable\"');\n        this.emit('readable', null);\n    }\n    if (eventFlag & exports.EVENTS.UV_WRITABLE) {\n        logger('received \"writable\"');\n        this.emit('writable', null);\n    }\n    if (eventFlag & exports.EVENTS.UV_DISCONNECT) {\n        logger('received \"disconnect\"');\n        this.emit('disconnect', null);\n    }\n}\n/**\n * Polls unix systems for readable or writable states of a file or serialport\n */\nclass Poller extends events_1.EventEmitter {\n    constructor(fd, FDPoller = PollerBindings) {\n        logger('Creating poller');\n        super();\n        this.poller = new FDPoller(fd, handleEvent.bind(this));\n    }\n    /**\n     * Wait for the next event to occur\n     * @param {string} event ('readable'|'writable'|'disconnect')\n     * @returns {Poller} returns itself\n     */\n    once(event, callback) {\n        switch (event) {\n            case 'readable':\n                this.poll(exports.EVENTS.UV_READABLE);\n                break;\n            case 'writable':\n                this.poll(exports.EVENTS.UV_WRITABLE);\n                break;\n            case 'disconnect':\n                this.poll(exports.EVENTS.UV_DISCONNECT);\n                break;\n        }\n        return super.once(event, callback);\n    }\n    /**\n     * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use\n     * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.\n     */\n    poll(eventFlag = 0) {\n        if (eventFlag & exports.EVENTS.UV_READABLE) {\n            logger('Polling for \"readable\"');\n        }\n        if (eventFlag & exports.EVENTS.UV_WRITABLE) {\n            logger('Polling for \"writable\"');\n        }\n        if (eventFlag & exports.EVENTS.UV_DISCONNECT) {\n            logger('Polling for \"disconnect\"');\n        }\n        this.poller.poll(eventFlag);\n    }\n    /**\n     * Stop listening for events and cancel all outstanding listening with an error\n     */\n    stop() {\n        logger('Stopping poller');\n        this.poller.stop();\n        this.emitCanceled();\n    }\n    destroy() {\n        logger('Destroying poller');\n        this.poller.destroy();\n        this.emitCanceled();\n    }\n    emitCanceled() {\n        const err = new errors_1.BindingsError('Canceled', { canceled: true });\n        this.emit('readable', err);\n        this.emit('writable', err);\n        this.emit('disconnect', err);\n    }\n}\nexports.Poller = Poller;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvcG9sbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWM7QUFDL0IsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVU7QUFDbkMsOEJBQThCLG1CQUFPLENBQUMsd0dBQXVCO0FBQzdELFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9iaW5kaW5ncy1jcHAvZGlzdC9wb2xsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxlciA9IGV4cG9ydHMuRVZFTlRTID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBzZXJpYWxwb3J0X2JpbmRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxwb3J0LWJpbmRpbmdzXCIpO1xuY29uc3QgeyBQb2xsZXI6IFBvbGxlckJpbmRpbmdzIH0gPSBzZXJpYWxwb3J0X2JpbmRpbmdzXzEuYmluZGluZztcbmNvbnN0IGxvZ2dlciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9wb2xsZXInKTtcbmV4cG9ydHMuRVZFTlRTID0ge1xuICAgIFVWX1JFQURBQkxFOiAwYjAwMDEsXG4gICAgVVZfV1JJVEFCTEU6IDBiMDAxMCxcbiAgICBVVl9ESVNDT05ORUNUOiAwYjAxMDAsXG59O1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXJyb3IsIGV2ZW50RmxhZykge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICBsb2dnZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJywgZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ3dyaXRhYmxlJywgZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50RmxhZyAmIGV4cG9ydHMuRVZFTlRTLlVWX1JFQURBQkxFKSB7XG4gICAgICAgIGxvZ2dlcigncmVjZWl2ZWQgXCJyZWFkYWJsZVwiJyk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50RmxhZyAmIGV4cG9ydHMuRVZFTlRTLlVWX1dSSVRBQkxFKSB7XG4gICAgICAgIGxvZ2dlcigncmVjZWl2ZWQgXCJ3cml0YWJsZVwiJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnd3JpdGFibGUnLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50RmxhZyAmIGV4cG9ydHMuRVZFTlRTLlVWX0RJU0NPTk5FQ1QpIHtcbiAgICAgICAgbG9nZ2VyKCdyZWNlaXZlZCBcImRpc2Nvbm5lY3RcIicpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBudWxsKTtcbiAgICB9XG59XG4vKipcbiAqIFBvbGxzIHVuaXggc3lzdGVtcyBmb3IgcmVhZGFibGUgb3Igd3JpdGFibGUgc3RhdGVzIG9mIGEgZmlsZSBvciBzZXJpYWxwb3J0XG4gKi9cbmNsYXNzIFBvbGxlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZmQsIEZEUG9sbGVyID0gUG9sbGVyQmluZGluZ3MpIHtcbiAgICAgICAgbG9nZ2VyKCdDcmVhdGluZyBwb2xsZXInKTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb2xsZXIgPSBuZXcgRkRQb2xsZXIoZmQsIGhhbmRsZUV2ZW50LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciB0aGUgbmV4dCBldmVudCB0byBvY2N1clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAoJ3JlYWRhYmxlJ3wnd3JpdGFibGUnfCdkaXNjb25uZWN0JylcbiAgICAgKiBAcmV0dXJucyB7UG9sbGVyfSByZXR1cm5zIGl0c2VsZlxuICAgICAqL1xuICAgIG9uY2UoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlYWRhYmxlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwoZXhwb3J0cy5FVkVOVFMuVVZfUkVBREFCTEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd3JpdGFibGUnOlxuICAgICAgICAgICAgICAgIHRoaXMucG9sbChleHBvcnRzLkVWRU5UUy5VVl9XUklUQUJMRSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwoZXhwb3J0cy5FVkVOVFMuVVZfRElTQ09OTkVDVCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uY2UoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNrIHRoZSBiaW5kaW5ncyB0byBsaXN0ZW4gZm9yIGFuIGV2ZW50LCBpdCBpcyByZWNvbW1lbmQgdG8gdXNlIGAub25jZSgpYCBmb3IgZWFzeSB1c2VcbiAgICAgKiBAcGFyYW0ge0VWRU5UU30gZXZlbnRGbGFnIHBvbGxzIGZvciBhbiBldmVudCBvciBncm91cCBvZiBldmVudHMgYmFzZWQgdXBvbiBhIGZsYWcuXG4gICAgICovXG4gICAgcG9sbChldmVudEZsYWcgPSAwKSB7XG4gICAgICAgIGlmIChldmVudEZsYWcgJiBleHBvcnRzLkVWRU5UUy5VVl9SRUFEQUJMRSkge1xuICAgICAgICAgICAgbG9nZ2VyKCdQb2xsaW5nIGZvciBcInJlYWRhYmxlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRGbGFnICYgZXhwb3J0cy5FVkVOVFMuVVZfV1JJVEFCTEUpIHtcbiAgICAgICAgICAgIGxvZ2dlcignUG9sbGluZyBmb3IgXCJ3cml0YWJsZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50RmxhZyAmIGV4cG9ydHMuRVZFTlRTLlVWX0RJU0NPTk5FQ1QpIHtcbiAgICAgICAgICAgIGxvZ2dlcignUG9sbGluZyBmb3IgXCJkaXNjb25uZWN0XCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbGxlci5wb2xsKGV2ZW50RmxhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgbGlzdGVuaW5nIGZvciBldmVudHMgYW5kIGNhbmNlbCBhbGwgb3V0c3RhbmRpbmcgbGlzdGVuaW5nIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBsb2dnZXIoJ1N0b3BwaW5nIHBvbGxlcicpO1xuICAgICAgICB0aGlzLnBvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuZW1pdENhbmNlbGVkKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGxvZ2dlcignRGVzdHJveWluZyBwb2xsZXInKTtcbiAgICAgICAgdGhpcy5wb2xsZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVtaXRDYW5jZWxlZCgpO1xuICAgIH1cbiAgICBlbWl0Q2FuY2VsZWQoKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBlcnJvcnNfMS5CaW5kaW5nc0Vycm9yKCdDYW5jZWxlZCcsIHsgY2FuY2VsZWQ6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnLCBlcnIpO1xuICAgICAgICB0aGlzLmVtaXQoJ3dyaXRhYmxlJywgZXJyKTtcbiAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgZXJyKTtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxlciA9IFBvbGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/poller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/serialport-bindings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/serialport-bindings.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.binding = void 0;\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst node_gyp_build_1 = __importDefault(__webpack_require__(/*! node-gyp-build */ \"(rsc)/./node_modules/node-gyp-build/index.js\"));\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexports.binding = (0, node_gyp_build_1.default)((0, path_1.join)(__dirname, '../'));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3Qvc2VyaWFscG9ydC1iaW5kaW5ncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IseUNBQXlDLG1CQUFPLENBQUMsb0VBQWdCO0FBQ2pFO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9kaXN0L3NlcmlhbHBvcnQtYmluZGluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpbmRpbmcgPSB2b2lkIDA7XG5jb25zdCBwYXRoXzEgPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IG5vZGVfZ3lwX2J1aWxkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGUtZ3lwLWJ1aWxkXCIpKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnRzLmJpbmRpbmcgPSAoMCwgbm9kZV9neXBfYnVpbGRfMS5kZWZhdWx0KSgoMCwgcGF0aF8xLmpvaW4pKF9fZGlybmFtZSwgJy4uLycpKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/serialport-bindings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-read.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/unix-read.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unixRead = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/errors.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst logger = (0, debug_1.default)('serialport/bindings-cpp/unixRead');\nconst readAsync = (0, util_1.promisify)(fs_1.read);\nconst readable = (binding) => {\n    return new Promise((resolve, reject) => {\n        if (!binding.poller) {\n            throw new Error('No poller on bindings');\n        }\n        binding.poller.once('readable', err => (err ? reject(err) : resolve()));\n    });\n};\nconst unixRead = async ({ binding, buffer, offset, length, fsReadAsync = readAsync, }) => {\n    logger('Starting read');\n    if (!binding.isOpen || !binding.fd) {\n        throw new errors_1.BindingsError('Port is not open', { canceled: true });\n    }\n    try {\n        const { bytesRead } = await fsReadAsync(binding.fd, buffer, offset, length, null);\n        if (bytesRead === 0) {\n            return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });\n        }\n        logger('Finished read', bytesRead, 'bytes');\n        return { bytesRead, buffer };\n    }\n    catch (err) {\n        logger('read error', err);\n        if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n            if (!binding.isOpen) {\n                throw new errors_1.BindingsError('Port is not open', { canceled: true });\n            }\n            logger('waiting for readable because of code:', err.code);\n            await readable(binding);\n            return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });\n        }\n        const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n            err.code === 'ENXIO' || // No such device or address probably usb disconnect\n            err.code === 'UNKNOWN' ||\n            err.errno === -1; // generic error\n        if (disconnectError) {\n            err.disconnect = true;\n            logger('disconnecting', err);\n        }\n        throw err;\n    }\n};\nexports.unixRead = unixRead;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvdW5peC1yZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixhQUFhLG1CQUFPLENBQUMsY0FBSTtBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVTtBQUNuQyxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLDJEQUEyRDtBQUNyRjtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSwyQ0FBMkMsOENBQThDO0FBQ3pGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxnQkFBZ0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhDQUE4QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9kaXN0L3VuaXgtcmVhZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5peFJlYWQgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGxvZ2dlciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC91bml4UmVhZCcpO1xuY29uc3QgcmVhZEFzeW5jID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzXzEucmVhZCk7XG5jb25zdCByZWFkYWJsZSA9IChiaW5kaW5nKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKCFiaW5kaW5nLnBvbGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwb2xsZXIgb24gYmluZGluZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nLnBvbGxlci5vbmNlKCdyZWFkYWJsZScsIGVyciA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpKTtcbiAgICB9KTtcbn07XG5jb25zdCB1bml4UmVhZCA9IGFzeW5jICh7IGJpbmRpbmcsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIGZzUmVhZEFzeW5jID0gcmVhZEFzeW5jLCB9KSA9PiB7XG4gICAgbG9nZ2VyKCdTdGFydGluZyByZWFkJyk7XG4gICAgaWYgKCFiaW5kaW5nLmlzT3BlbiB8fCAhYmluZGluZy5mZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQmluZGluZ3NFcnJvcignUG9ydCBpcyBub3Qgb3BlbicsIHsgY2FuY2VsZWQ6IHRydWUgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgYnl0ZXNSZWFkIH0gPSBhd2FpdCBmc1JlYWRBc3luYyhiaW5kaW5nLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBudWxsKTtcbiAgICAgICAgaWYgKGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnVuaXhSZWFkKSh7IGJpbmRpbmcsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIGZzUmVhZEFzeW5jIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcignRmluaXNoZWQgcmVhZCcsIGJ5dGVzUmVhZCwgJ2J5dGVzJyk7XG4gICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZCwgYnVmZmVyIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyKCdyZWFkIGVycm9yJywgZXJyKTtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRUFHQUlOJyB8fCBlcnIuY29kZSA9PT0gJ0VXT1VMREJMT0NLJyB8fCBlcnIuY29kZSA9PT0gJ0VJTlRSJykge1xuICAgICAgICAgICAgaWYgKCFiaW5kaW5nLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5CaW5kaW5nc0Vycm9yKCdQb3J0IGlzIG5vdCBvcGVuJywgeyBjYW5jZWxlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcignd2FpdGluZyBmb3IgcmVhZGFibGUgYmVjYXVzZSBvZiBjb2RlOicsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRhYmxlKGJpbmRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnVuaXhSZWFkKSh7IGJpbmRpbmcsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIGZzUmVhZEFzeW5jIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RFcnJvciA9IGVyci5jb2RlID09PSAnRUJBREYnIHx8IC8vIEJhZCBmaWxlIG51bWJlciBtZWFucyB3ZSBnb3QgY2xvc2VkXG4gICAgICAgICAgICBlcnIuY29kZSA9PT0gJ0VOWElPJyB8fCAvLyBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzIHByb2JhYmx5IHVzYiBkaXNjb25uZWN0XG4gICAgICAgICAgICBlcnIuY29kZSA9PT0gJ1VOS05PV04nIHx8XG4gICAgICAgICAgICBlcnIuZXJybm8gPT09IC0xOyAvLyBnZW5lcmljIGVycm9yXG4gICAgICAgIGlmIChkaXNjb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIGVyci5kaXNjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZ2dlcignZGlzY29ubmVjdGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5leHBvcnRzLnVuaXhSZWFkID0gdW5peFJlYWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-read.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-write.js":
/*!******************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/unix-write.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unixWrite = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst logger = (0, debug_1.default)('serialport/bindings-cpp/unixWrite');\nconst writeAsync = (0, util_1.promisify)(fs_1.write);\nconst writable = (binding) => {\n    return new Promise((resolve, reject) => {\n        binding.poller.once('writable', err => (err ? reject(err) : resolve()));\n    });\n};\nconst unixWrite = async ({ binding, buffer, offset = 0, fsWriteAsync = writeAsync }) => {\n    const bytesToWrite = buffer.length - offset;\n    logger('Starting write', buffer.length, 'bytes offset', offset, 'bytesToWrite', bytesToWrite);\n    if (!binding.isOpen || !binding.fd) {\n        throw new Error('Port is not open');\n    }\n    try {\n        const { bytesWritten } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite);\n        logger('write returned: wrote', bytesWritten, 'bytes');\n        if (bytesWritten + offset < buffer.length) {\n            if (!binding.isOpen) {\n                throw new Error('Port is not open');\n            }\n            return (0, exports.unixWrite)({ binding, buffer, offset: bytesWritten + offset, fsWriteAsync });\n        }\n        logger('Finished writing', bytesWritten + offset, 'bytes');\n    }\n    catch (err) {\n        logger('write errored', err);\n        if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n            if (!binding.isOpen) {\n                throw new Error('Port is not open');\n            }\n            logger('waiting for writable because of code:', err.code);\n            await writable(binding);\n            return (0, exports.unixWrite)({ binding, buffer, offset, fsWriteAsync });\n        }\n        const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n            err.code === 'ENXIO' || // No such device or address probably usb disconnect\n            err.code === 'UNKNOWN' ||\n            err.errno === -1; // generic error\n        if (disconnectError) {\n            err.disconnect = true;\n            logger('disconnecting', err);\n        }\n        logger('error', err);\n        throw err;\n    }\n};\nexports.unixWrite = unixWrite;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3QvdW5peC13cml0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixhQUFhLG1CQUFPLENBQUMsY0FBSTtBQUN6QixnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQix3REFBd0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4REFBOEQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1Q0FBdUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9kaXN0L3VuaXgtd3JpdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaXhXcml0ZSA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGxvZ2dlciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC91bml4V3JpdGUnKTtcbmNvbnN0IHdyaXRlQXN5bmMgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS53cml0ZSk7XG5jb25zdCB3cml0YWJsZSA9IChiaW5kaW5nKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgYmluZGluZy5wb2xsZXIub25jZSgnd3JpdGFibGUnLCBlcnIgPT4gKGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKSk7XG4gICAgfSk7XG59O1xuY29uc3QgdW5peFdyaXRlID0gYXN5bmMgKHsgYmluZGluZywgYnVmZmVyLCBvZmZzZXQgPSAwLCBmc1dyaXRlQXN5bmMgPSB3cml0ZUFzeW5jIH0pID0+IHtcbiAgICBjb25zdCBieXRlc1RvV3JpdGUgPSBidWZmZXIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGxvZ2dlcignU3RhcnRpbmcgd3JpdGUnLCBidWZmZXIubGVuZ3RoLCAnYnl0ZXMgb2Zmc2V0Jywgb2Zmc2V0LCAnYnl0ZXNUb1dyaXRlJywgYnl0ZXNUb1dyaXRlKTtcbiAgICBpZiAoIWJpbmRpbmcuaXNPcGVuIHx8ICFiaW5kaW5nLmZkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGJ5dGVzV3JpdHRlbiB9ID0gYXdhaXQgZnNXcml0ZUFzeW5jKGJpbmRpbmcuZmQsIGJ1ZmZlciwgb2Zmc2V0LCBieXRlc1RvV3JpdGUpO1xuICAgICAgICBsb2dnZXIoJ3dyaXRlIHJldHVybmVkOiB3cm90ZScsIGJ5dGVzV3JpdHRlbiwgJ2J5dGVzJyk7XG4gICAgICAgIGlmIChieXRlc1dyaXR0ZW4gKyBvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmcuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMudW5peFdyaXRlKSh7IGJpbmRpbmcsIGJ1ZmZlciwgb2Zmc2V0OiBieXRlc1dyaXR0ZW4gKyBvZmZzZXQsIGZzV3JpdGVBc3luYyB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIoJ0ZpbmlzaGVkIHdyaXRpbmcnLCBieXRlc1dyaXR0ZW4gKyBvZmZzZXQsICdieXRlcycpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcignd3JpdGUgZXJyb3JlZCcsIGVycik7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VBR0FJTicgfHwgZXJyLmNvZGUgPT09ICdFV09VTERCTE9DSycgfHwgZXJyLmNvZGUgPT09ICdFSU5UUicpIHtcbiAgICAgICAgICAgIGlmICghYmluZGluZy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcignd2FpdGluZyBmb3Igd3JpdGFibGUgYmVjYXVzZSBvZiBjb2RlOicsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGF3YWl0IHdyaXRhYmxlKGJpbmRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnVuaXhXcml0ZSkoeyBiaW5kaW5nLCBidWZmZXIsIG9mZnNldCwgZnNXcml0ZUFzeW5jIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RFcnJvciA9IGVyci5jb2RlID09PSAnRUJBREYnIHx8IC8vIEJhZCBmaWxlIG51bWJlciBtZWFucyB3ZSBnb3QgY2xvc2VkXG4gICAgICAgICAgICBlcnIuY29kZSA9PT0gJ0VOWElPJyB8fCAvLyBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzIHByb2JhYmx5IHVzYiBkaXNjb25uZWN0XG4gICAgICAgICAgICBlcnIuY29kZSA9PT0gJ1VOS05PV04nIHx8XG4gICAgICAgICAgICBlcnIuZXJybm8gPT09IC0xOyAvLyBnZW5lcmljIGVycm9yXG4gICAgICAgIGlmIChkaXNjb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIGVyci5kaXNjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZ2dlcignZGlzY29ubmVjdGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuZXhwb3J0cy51bml4V3JpdGUgPSB1bml4V3JpdGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/unix-write.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serialNumParser = void 0;\nconst PARSERS = [/USB\\\\(?:.+)\\\\(.+)/, /FTDIBUS\\\\(?:.+)\\+(.+?)A?\\\\.+/];\nconst serialNumParser = (pnpId) => {\n    if (!pnpId) {\n        return null;\n    }\n    for (const parser of PARSERS) {\n        const sn = pnpId.match(parser);\n        if (sn) {\n            return sn[1];\n        }\n    }\n    return null;\n};\nexports.serialNumParser = serialNumParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3Qvd2luMzItc24tcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcC9kaXN0L3dpbjMyLXNuLXBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VyaWFsTnVtUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgUEFSU0VSUyA9IFsvVVNCXFxcXCg/Oi4rKVxcXFwoLispLywgL0ZURElCVVNcXFxcKD86LispXFwrKC4rPylBP1xcXFwuKy9dO1xuY29uc3Qgc2VyaWFsTnVtUGFyc2VyID0gKHBucElkKSA9PiB7XG4gICAgaWYgKCFwbnBJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJzZXIgb2YgUEFSU0VSUykge1xuICAgICAgICBjb25zdCBzbiA9IHBucElkLm1hdGNoKHBhcnNlcik7XG4gICAgICAgIGlmIChzbikge1xuICAgICAgICAgICAgcmV0dXJuIHNuWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmV4cG9ydHMuc2VyaWFsTnVtUGFyc2VyID0gc2VyaWFsTnVtUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32.js":
/*!*************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/dist/win32.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WindowsPortBinding = exports.WindowsBinding = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst _1 = __webpack_require__(/*! . */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/index.js\");\nconst load_bindings_1 = __webpack_require__(/*! ./load-bindings */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/load-bindings.js\");\nconst win32_sn_parser_1 = __webpack_require__(/*! ./win32-sn-parser */ \"(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js\");\nconst debug = (0, debug_1.default)('serialport/bindings-cpp');\nexports.WindowsBinding = {\n    async list() {\n        const ports = await (0, load_bindings_1.asyncList)();\n        // Grab the serial number from the pnp id\n        return ports.map(port => {\n            if (port.pnpId && !port.serialNumber) {\n                const serialNumber = (0, win32_sn_parser_1.serialNumParser)(port.pnpId);\n                if (serialNumber) {\n                    return Object.assign(Object.assign({}, port), { serialNumber });\n                }\n            }\n            return port;\n        });\n    },\n    async open(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        debug('open');\n        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, rtsMode: 'handshake', xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);\n        return new WindowsPortBinding(fd, openOptions);\n    },\n};\n/**\n * The Windows binding layer\n */\nclass WindowsPortBinding {\n    constructor(fd, options) {\n        this.fd = fd;\n        this.openOptions = options;\n        this.writeOperation = null;\n    }\n    get isOpen() {\n        return this.fd !== null;\n    }\n    async close() {\n        debug('close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const fd = this.fd;\n        this.fd = null;\n        await (0, load_bindings_1.asyncClose)(fd);\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        debug('read');\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        try {\n            const bytesRead = await (0, load_bindings_1.asyncRead)(this.fd, buffer, offset, length);\n            return { bytesRead, buffer };\n        }\n        catch (err) {\n            if (!this.isOpen) {\n                throw new _1.BindingsError(err.message, { canceled: true });\n            }\n            throw err;\n        }\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        debug('write', buffer.length, 'bytes');\n        if (!this.isOpen) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        this.writeOperation = (async () => {\n            if (buffer.length === 0) {\n                return;\n            }\n            await (0, load_bindings_1.asyncWrite)(this.fd, buffer);\n            this.writeOperation = null;\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug('update');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncUpdate)(this.fd, options);\n    }\n    async set(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug('set', options);\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncSet)(this.fd, options);\n    }\n    async get() {\n        debug('get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGet)(this.fd);\n    }\n    async getBaudRate() {\n        debug('getBaudRate');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);\n    }\n    async flush() {\n        debug('flush');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncFlush)(this.fd);\n    }\n    async drain() {\n        debug('drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await (0, load_bindings_1.asyncDrain)(this.fd);\n    }\n}\nexports.WindowsPortBinding = WindowsPortBinding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL2Rpc3Qvd2luMzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0I7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0MsV0FBVyxtQkFBTyxDQUFDLHNFQUFHO0FBQ3RCLHdCQUF3QixtQkFBTyxDQUFDLDRGQUFpQjtBQUNqRCwwQkFBMEIsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDckQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVyxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4SUFBOEk7QUFDMUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQSxtRUFBbUUsc0NBQXNDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9iaW5kaW5ncy1jcHAvZGlzdC93aW4zMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2luZG93c1BvcnRCaW5kaW5nID0gZXhwb3J0cy5XaW5kb3dzQmluZGluZyA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IF8xID0gcmVxdWlyZShcIi5cIik7XG5jb25zdCBsb2FkX2JpbmRpbmdzXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJpbmRpbmdzXCIpO1xuY29uc3Qgd2luMzJfc25fcGFyc2VyXzEgPSByZXF1aXJlKFwiLi93aW4zMi1zbi1wYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdzZXJpYWxwb3J0L2JpbmRpbmdzLWNwcCcpO1xuZXhwb3J0cy5XaW5kb3dzQmluZGluZyA9IHtcbiAgICBhc3luYyBsaXN0KCkge1xuICAgICAgICBjb25zdCBwb3J0cyA9IGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNMaXN0KSgpO1xuICAgICAgICAvLyBHcmFiIHRoZSBzZXJpYWwgbnVtYmVyIGZyb20gdGhlIHBucCBpZFxuICAgICAgICByZXR1cm4gcG9ydHMubWFwKHBvcnQgPT4ge1xuICAgICAgICAgICAgaWYgKHBvcnQucG5wSWQgJiYgIXBvcnQuc2VyaWFsTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsTnVtYmVyID0gKDAsIHdpbjMyX3NuX3BhcnNlcl8xLnNlcmlhbE51bVBhcnNlcikocG9ydC5wbnBJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbE51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwb3J0KSwgeyBzZXJpYWxOdW1iZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvcnQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXN5bmMgb3BlbihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zXCIgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhdGhcIiBpcyBub3QgYSB2YWxpZCBwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmJhdWRSYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJhdWRSYXRlXCIgaXMgbm90IGEgdmFsaWQgYmF1ZFJhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnb3BlbicpO1xuICAgICAgICBjb25zdCBvcGVuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBkYXRhQml0czogOCwgbG9jazogdHJ1ZSwgc3RvcEJpdHM6IDEsIHBhcml0eTogJ25vbmUnLCBydHNjdHM6IGZhbHNlLCBydHNNb2RlOiAnaGFuZHNoYWtlJywgeG9uOiBmYWxzZSwgeG9mZjogZmFsc2UsIHhhbnk6IGZhbHNlLCBodXBjbDogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmQgPSBhd2FpdCAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jT3Blbikob3Blbk9wdGlvbnMucGF0aCwgb3Blbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFdpbmRvd3NQb3J0QmluZGluZyhmZCwgb3Blbk9wdGlvbnMpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBUaGUgV2luZG93cyBiaW5kaW5nIGxheWVyXG4gKi9cbmNsYXNzIFdpbmRvd3NQb3J0QmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5mZCA9IGZkO1xuICAgICAgICB0aGlzLm9wZW5PcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy53cml0ZU9wZXJhdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZkICE9PSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZkID0gdGhpcy5mZDtcbiAgICAgICAgdGhpcy5mZCA9IG51bGw7XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNDbG9zZSkoZmQpO1xuICAgIH1cbiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBpcyBub3QgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJvZmZzZXRcIiBpcyBub3QgYW4gaW50ZWdlciBnb3QgXCIke2lzTmFOKG9mZnNldCkgPyAnTmFOJyA6IHR5cGVvZiBvZmZzZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJsZW5ndGhcIiBpcyBub3QgYW4gaW50ZWdlciBnb3QgXCIke2lzTmFOKGxlbmd0aCkgPyAnTmFOJyA6IHR5cGVvZiBsZW5ndGh9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygncmVhZCcpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgaXMgdG9vIHNtYWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNSZWFkKSh0aGlzLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZCwgYnVmZmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBfMS5CaW5kaW5nc0Vycm9yKGVyci5tZXNzYWdlLCB7IGNhbmNlbGVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGlzIG5vdCBhIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCd3cml0ZScsIGJ1ZmZlci5sZW5ndGgsICdieXRlcycpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICBkZWJ1Zygnd3JpdGUnLCAnZXJyb3IgcG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZU9wZXJhdGlvbiA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNXcml0ZSkodGhpcy5mZCwgYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZU9wZXJhdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1wib3B0aW9uc1wiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmF1ZFJhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuYmF1ZFJhdGVcIiBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygndXBkYXRlJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNVcGRhdGUpKHRoaXMuZmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXQob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9uc1wiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc2V0Jywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNTZXQpKHRoaXMuZmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXQoKSB7XG4gICAgICAgIGRlYnVnKCdnZXQnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNHZXQpKHRoaXMuZmQpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYXVkUmF0ZSgpIHtcbiAgICAgICAgZGVidWcoJ2dldEJhdWRSYXRlJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgbG9hZF9iaW5kaW5nc18xLmFzeW5jR2V0QmF1ZFJhdGUpKHRoaXMuZmQpO1xuICAgIH1cbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgZGVidWcoJ2ZsdXNoJyk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0ICgwLCBsb2FkX2JpbmRpbmdzXzEuYXN5bmNGbHVzaCkodGhpcy5mZCk7XG4gICAgfVxuICAgIGFzeW5jIGRyYWluKCkge1xuICAgICAgICBkZWJ1ZygnZHJhaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZU9wZXJhdGlvbjtcbiAgICAgICAgYXdhaXQgKDAsIGxvYWRfYmluZGluZ3NfMS5hc3luY0RyYWluKSh0aGlzLmZkKTtcbiAgICB9XG59XG5leHBvcnRzLldpbmRvd3NQb3J0QmluZGluZyA9IFdpbmRvd3NQb3J0QmluZGluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/dist/win32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-delimiter/dist/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-delimiter/dist/index.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DelimiterParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that emits data each time a byte sequence is received.\n * @extends Transform\n *\n * To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.\n */\nclass DelimiterParser extends stream_1.Transform {\n    includeDelimiter;\n    delimiter;\n    buffer;\n    constructor({ delimiter, includeDelimiter = false, ...options }) {\n        super(options);\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        this.includeDelimiter = includeDelimiter;\n        this.delimiter = Buffer.from(delimiter);\n        this.buffer = Buffer.alloc(0);\n    }\n    _transform(chunk, encoding, cb) {\n        let data = Buffer.concat([this.buffer, chunk]);\n        let position;\n        while ((position = data.indexOf(this.delimiter)) !== -1) {\n            this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));\n            data = data.slice(position + this.delimiter.length);\n        }\n        this.buffer = data;\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.DelimiterParser = DelimiterParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItZGVsaW1pdGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9iaW5kaW5ncy1jcHAvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L3BhcnNlci1kZWxpbWl0ZXIvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVsaW1pdGVyUGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLyoqXG4gKiBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbWl0cyBkYXRhIGVhY2ggdGltZSBhIGJ5dGUgc2VxdWVuY2UgaXMgcmVjZWl2ZWQuXG4gKiBAZXh0ZW5kcyBUcmFuc2Zvcm1cbiAqXG4gKiBUbyB1c2UgdGhlIGBEZWxpbWl0ZXJgIHBhcnNlciwgcHJvdmlkZSBhIGRlbGltaXRlciBhcyBhIHN0cmluZywgYnVmZmVyLCBvciBhcnJheSBvZiBieXRlcy4gUnVucyBpbiBPKG4pIHRpbWUuXG4gKi9cbmNsYXNzIERlbGltaXRlclBhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgaW5jbHVkZURlbGltaXRlcjtcbiAgICBkZWxpbWl0ZXI7XG4gICAgYnVmZmVyO1xuICAgIGNvbnN0cnVjdG9yKHsgZGVsaW1pdGVyLCBpbmNsdWRlRGVsaW1pdGVyID0gZmFsc2UsIC4uLm9wdGlvbnMgfSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgaWYgKGRlbGltaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlbGltaXRlclwiIGlzIG5vdCBhIGJ1ZmZlcmFibGUgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGltaXRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVsaW1pdGVyXCIgaGFzIGEgMCBvciB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmNsdWRlRGVsaW1pdGVyID0gaW5jbHVkZURlbGltaXRlcjtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBCdWZmZXIuZnJvbShkZWxpbWl0ZXIpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGxldCBkYXRhID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIsIGNodW5rXSk7XG4gICAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgICAgd2hpbGUgKChwb3NpdGlvbiA9IGRhdGEuaW5kZXhPZih0aGlzLmRlbGltaXRlcikpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEuc2xpY2UoMCwgcG9zaXRpb24gKyAodGhpcy5pbmNsdWRlRGVsaW1pdGVyID8gdGhpcy5kZWxpbWl0ZXIubGVuZ3RoIDogMCkpKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKHBvc2l0aW9uICsgdGhpcy5kZWxpbWl0ZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGRhdGE7XG4gICAgICAgIGNiKCk7XG4gICAgfVxuICAgIF9mbHVzaChjYikge1xuICAgICAgICB0aGlzLnB1c2godGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkRlbGltaXRlclBhcnNlciA9IERlbGltaXRlclBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-delimiter/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-readline/dist/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-readline/dist/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadlineParser = void 0;\nconst parser_delimiter_1 = __webpack_require__(/*! @serialport/parser-delimiter */ \"(rsc)/./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-delimiter/dist/index.js\");\n/**\n *  A transform stream that emits data after a newline delimiter is received.\n * @summary To use the `Readline` parser, provide a delimiter (defaults to `\\n`). Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n */\nclass ReadlineParser extends parser_delimiter_1.DelimiterParser {\n    constructor(options) {\n        const opts = {\n            delimiter: Buffer.from('\\n', 'utf8'),\n            encoding: 'utf8',\n            ...options,\n        };\n        if (typeof opts.delimiter === 'string') {\n            opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);\n        }\n        super(opts);\n    }\n}\nexports.ReadlineParser = ReadlineParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtY3BwL25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItcmVhZGxpbmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsMkJBQTJCLG1CQUFPLENBQUMsMklBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9iaW5kaW5ncy1jcHAvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L3BhcnNlci1yZWFkbGluZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFkbGluZVBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHBhcnNlcl9kZWxpbWl0ZXJfMSA9IHJlcXVpcmUoXCJAc2VyaWFscG9ydC9wYXJzZXItZGVsaW1pdGVyXCIpO1xuLyoqXG4gKiAgQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW1pdHMgZGF0YSBhZnRlciBhIG5ld2xpbmUgZGVsaW1pdGVyIGlzIHJlY2VpdmVkLlxuICogQHN1bW1hcnkgVG8gdXNlIHRoZSBgUmVhZGxpbmVgIHBhcnNlciwgcHJvdmlkZSBhIGRlbGltaXRlciAoZGVmYXVsdHMgdG8gYFxcbmApLiBEYXRhIGlzIGVtaXR0ZWQgYXMgc3RyaW5nIGNvbnRyb2xsYWJsZSBieSB0aGUgYGVuY29kaW5nYCBvcHRpb24gKGRlZmF1bHRzIHRvIGB1dGY4YCkuXG4gKi9cbmNsYXNzIFJlYWRsaW5lUGFyc2VyIGV4dGVuZHMgcGFyc2VyX2RlbGltaXRlcl8xLkRlbGltaXRlclBhcnNlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgZGVsaW1pdGVyOiBCdWZmZXIuZnJvbSgnXFxuJywgJ3V0ZjgnKSxcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0cy5kZWxpbWl0ZXIgPSBCdWZmZXIuZnJvbShvcHRzLmRlbGltaXRlciwgb3B0cy5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkbGluZVBhcnNlciA9IFJlYWRsaW5lUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-cpp/node_modules/@serialport/parser-readline/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/bindings-interface/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@serialport/bindings-interface/dist/index.js ***!
  \*******************************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvYmluZGluZ3MtaW50ZXJmYWNlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9iaW5kaW5ncy1pbnRlcmZhY2UvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/bindings-interface/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-byte-length/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@serialport/parser-byte-length/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ByteLengthParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emit data every number of bytes\n *\n * A transform stream that emits data as a buffer after a specific number of bytes are received. Runs in O(n) time.\n */\nclass ByteLengthParser extends stream_1.Transform {\n    length;\n    position;\n    buffer;\n    constructor(options) {\n        super(options);\n        if (typeof options.length !== 'number') {\n            throw new TypeError('\"length\" is not a number');\n        }\n        if (options.length < 1) {\n            throw new TypeError('\"length\" is not greater than 0');\n        }\n        this.length = options.length;\n        this.position = 0;\n        this.buffer = Buffer.alloc(this.length);\n    }\n    _transform(chunk, _encoding, cb) {\n        let cursor = 0;\n        while (cursor < chunk.length) {\n            this.buffer[this.position] = chunk[cursor];\n            cursor++;\n            this.position++;\n            if (this.position === this.length) {\n                this.push(this.buffer);\n                this.buffer = Buffer.alloc(this.length);\n                this.position = 0;\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer.slice(0, this.position));\n        this.buffer = Buffer.alloc(this.length);\n        cb();\n    }\n}\nexports.ByteLengthParser = ByteLengthParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLWJ5dGUtbGVuZ3RoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItYnl0ZS1sZW5ndGgvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZUxlbmd0aFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogRW1pdCBkYXRhIGV2ZXJ5IG51bWJlciBvZiBieXRlc1xuICpcbiAqIEEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVtaXRzIGRhdGEgYXMgYSBidWZmZXIgYWZ0ZXIgYSBzcGVjaWZpYyBudW1iZXIgb2YgYnl0ZXMgYXJlIHJlY2VpdmVkLiBSdW5zIGluIE8obikgdGltZS5cbiAqL1xuY2xhc3MgQnl0ZUxlbmd0aFBhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgbGVuZ3RoO1xuICAgIHBvc2l0aW9uO1xuICAgIGJ1ZmZlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsZW5ndGhcIiBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxlbmd0aFwiIGlzIG5vdCBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIF9lbmNvZGluZywgY2IpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IDA7XG4gICAgICAgIHdoaWxlIChjdXJzb3IgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb25dID0gY2h1bmtbY3Vyc29yXTtcbiAgICAgICAgICAgIGN1cnNvcisrO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNiKSB7XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkJ5dGVMZW5ndGhQYXJzZXIgPSBCeXRlTGVuZ3RoUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-byte-length/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-cctalk/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@serialport/parser-cctalk/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CCTalkParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Parse the CCTalk protocol\n * @extends Transform\n *\n * A transform stream that emits CCTalk packets as they are received.\n */\nclass CCTalkParser extends stream_1.Transform {\n    array;\n    cursor;\n    lastByteFetchTime;\n    maxDelayBetweenBytesMs;\n    constructor(maxDelayBetweenBytesMs = 50) {\n        super();\n        this.array = [];\n        this.cursor = 0;\n        this.lastByteFetchTime = 0;\n        this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs;\n    }\n    _transform(buffer, encoding, cb) {\n        if (this.maxDelayBetweenBytesMs > 0) {\n            const now = Date.now();\n            if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {\n                this.array = [];\n                this.cursor = 0;\n            }\n            this.lastByteFetchTime = now;\n        }\n        this.cursor += buffer.length;\n        // TODO: Better Faster es7 no supported by node 4\n        // ES7 allows directly push [...buffer]\n        // this.array = this.array.concat(Array.from(buffer)) //Slower ?!?\n        Array.from(buffer).map(byte => this.array.push(byte));\n        while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {\n            // full frame accumulated\n            // copy command from the array\n            const FullMsgLength = this.array[1] + 5;\n            const frame = Buffer.from(this.array.slice(0, FullMsgLength));\n            // Preserve Extra Data\n            this.array = this.array.slice(frame.length, this.array.length);\n            this.cursor -= FullMsgLength;\n            this.push(frame);\n        }\n        cb();\n    }\n}\nexports.CCTalkParser = CCTalkParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLWNjdGFsay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItY2N0YWxrL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNDVGFsa1BhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogUGFyc2UgdGhlIENDVGFsayBwcm90b2NvbFxuICogQGV4dGVuZHMgVHJhbnNmb3JtXG4gKlxuICogQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW1pdHMgQ0NUYWxrIHBhY2tldHMgYXMgdGhleSBhcmUgcmVjZWl2ZWQuXG4gKi9cbmNsYXNzIENDVGFsa1BhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgYXJyYXk7XG4gICAgY3Vyc29yO1xuICAgIGxhc3RCeXRlRmV0Y2hUaW1lO1xuICAgIG1heERlbGF5QmV0d2VlbkJ5dGVzTXM7XG4gICAgY29uc3RydWN0b3IobWF4RGVsYXlCZXR3ZWVuQnl0ZXNNcyA9IDUwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgICAgICB0aGlzLmxhc3RCeXRlRmV0Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5tYXhEZWxheUJldHdlZW5CeXRlc01zID0gbWF4RGVsYXlCZXR3ZWVuQnl0ZXNNcztcbiAgICB9XG4gICAgX3RyYW5zZm9ybShidWZmZXIsIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodGhpcy5tYXhEZWxheUJldHdlZW5CeXRlc01zID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aGlzLmxhc3RCeXRlRmV0Y2hUaW1lID4gdGhpcy5tYXhEZWxheUJldHdlZW5CeXRlc01zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdEJ5dGVGZXRjaFRpbWUgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJzb3IgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gVE9ETzogQmV0dGVyIEZhc3RlciBlczcgbm8gc3VwcG9ydGVkIGJ5IG5vZGUgNFxuICAgICAgICAvLyBFUzcgYWxsb3dzIGRpcmVjdGx5IHB1c2ggWy4uLmJ1ZmZlcl1cbiAgICAgICAgLy8gdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuY29uY2F0KEFycmF5LmZyb20oYnVmZmVyKSkgLy9TbG93ZXIgPyE/XG4gICAgICAgIEFycmF5LmZyb20oYnVmZmVyKS5tYXAoYnl0ZSA9PiB0aGlzLmFycmF5LnB1c2goYnl0ZSkpO1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJzb3IgPiAxICYmIHRoaXMuY3Vyc29yID49IHRoaXMuYXJyYXlbMV0gKyA1KSB7XG4gICAgICAgICAgICAvLyBmdWxsIGZyYW1lIGFjY3VtdWxhdGVkXG4gICAgICAgICAgICAvLyBjb3B5IGNvbW1hbmQgZnJvbSB0aGUgYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IEZ1bGxNc2dMZW5ndGggPSB0aGlzLmFycmF5WzFdICsgNTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gQnVmZmVyLmZyb20odGhpcy5hcnJheS5zbGljZSgwLCBGdWxsTXNnTGVuZ3RoKSk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBFeHRyYSBEYXRhXG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5zbGljZShmcmFtZS5sZW5ndGgsIHRoaXMuYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yIC09IEZ1bGxNc2dMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DQ1RhbGtQYXJzZXIgPSBDQ1RhbGtQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-cctalk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-delimiter/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@serialport/parser-delimiter/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DelimiterParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that emits data each time a byte sequence is received.\n * @extends Transform\n *\n * To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.\n */\nclass DelimiterParser extends stream_1.Transform {\n    includeDelimiter;\n    delimiter;\n    buffer;\n    constructor({ delimiter, includeDelimiter = false, ...options }) {\n        super(options);\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        this.includeDelimiter = includeDelimiter;\n        this.delimiter = Buffer.from(delimiter);\n        this.buffer = Buffer.alloc(0);\n    }\n    _transform(chunk, encoding, cb) {\n        let data = Buffer.concat([this.buffer, chunk]);\n        let position;\n        while ((position = data.indexOf(this.delimiter)) !== -1) {\n            this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));\n            data = data.slice(position + this.delimiter.length);\n        }\n        this.buffer = data;\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.DelimiterParser = DelimiterParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLWRlbGltaXRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBaUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLWRlbGltaXRlci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWxpbWl0ZXJQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4vKipcbiAqIEEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVtaXRzIGRhdGEgZWFjaCB0aW1lIGEgYnl0ZSBzZXF1ZW5jZSBpcyByZWNlaXZlZC5cbiAqIEBleHRlbmRzIFRyYW5zZm9ybVxuICpcbiAqIFRvIHVzZSB0aGUgYERlbGltaXRlcmAgcGFyc2VyLCBwcm92aWRlIGEgZGVsaW1pdGVyIGFzIGEgc3RyaW5nLCBidWZmZXIsIG9yIGFycmF5IG9mIGJ5dGVzLiBSdW5zIGluIE8obikgdGltZS5cbiAqL1xuY2xhc3MgRGVsaW1pdGVyUGFyc2VyIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBpbmNsdWRlRGVsaW1pdGVyO1xuICAgIGRlbGltaXRlcjtcbiAgICBidWZmZXI7XG4gICAgY29uc3RydWN0b3IoeyBkZWxpbWl0ZXIsIGluY2x1ZGVEZWxpbWl0ZXIgPSBmYWxzZSwgLi4ub3B0aW9ucyB9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVsaW1pdGVyXCIgaXMgbm90IGEgYnVmZmVyYWJsZSBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWxpbWl0ZXJcIiBoYXMgYSAwIG9yIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluY2x1ZGVEZWxpbWl0ZXIgPSBpbmNsdWRlRGVsaW1pdGVyO1xuICAgICAgICB0aGlzLmRlbGltaXRlciA9IEJ1ZmZlci5mcm9tKGRlbGltaXRlcik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlciwgY2h1bmtdKTtcbiAgICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgICB3aGlsZSAoKHBvc2l0aW9uID0gZGF0YS5pbmRleE9mKHRoaXMuZGVsaW1pdGVyKSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goZGF0YS5zbGljZSgwLCBwb3NpdGlvbiArICh0aGlzLmluY2x1ZGVEZWxpbWl0ZXIgPyB0aGlzLmRlbGltaXRlci5sZW5ndGggOiAwKSkpO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UocG9zaXRpb24gKyB0aGlzLmRlbGltaXRlci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZGF0YTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNiKSB7XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVsaW1pdGVyUGFyc2VyID0gRGVsaW1pdGVyUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-delimiter/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-inter-byte-timeout/dist/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@serialport/parser-inter-byte-timeout/dist/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InterByteTimeoutParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that buffers data and emits it after not receiving any bytes for the specified amount of time or hitting a max buffer size.\n */\nclass InterByteTimeoutParser extends stream_1.Transform {\n    maxBufferSize;\n    currentPacket;\n    interval;\n    intervalID;\n    constructor({ maxBufferSize = 65536, interval, ...transformOptions }) {\n        super(transformOptions);\n        if (!interval) {\n            throw new TypeError('\"interval\" is required');\n        }\n        if (typeof interval !== 'number' || Number.isNaN(interval)) {\n            throw new TypeError('\"interval\" is not a number');\n        }\n        if (interval < 1) {\n            throw new TypeError('\"interval\" is not greater than 0');\n        }\n        if (typeof maxBufferSize !== 'number' || Number.isNaN(maxBufferSize)) {\n            throw new TypeError('\"maxBufferSize\" is not a number');\n        }\n        if (maxBufferSize < 1) {\n            throw new TypeError('\"maxBufferSize\" is not greater than 0');\n        }\n        this.maxBufferSize = maxBufferSize;\n        this.currentPacket = [];\n        this.interval = interval;\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.intervalID) {\n            clearTimeout(this.intervalID);\n        }\n        for (let offset = 0; offset < chunk.length; offset++) {\n            this.currentPacket.push(chunk[offset]);\n            if (this.currentPacket.length >= this.maxBufferSize) {\n                this.emitPacket();\n            }\n        }\n        this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);\n        cb();\n    }\n    emitPacket() {\n        if (this.intervalID) {\n            clearTimeout(this.intervalID);\n        }\n        if (this.currentPacket.length > 0) {\n            this.push(Buffer.from(this.currentPacket));\n        }\n        this.currentPacket = [];\n    }\n    _flush(cb) {\n        this.emitPacket();\n        cb();\n    }\n}\nexports.InterByteTimeoutParser = InterByteTimeoutParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLWludGVyLWJ5dGUtdGltZW91dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFzRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLWludGVyLWJ5dGUtdGltZW91dC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlckJ5dGVUaW1lb3V0UGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLyoqXG4gKiBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBidWZmZXJzIGRhdGEgYW5kIGVtaXRzIGl0IGFmdGVyIG5vdCByZWNlaXZpbmcgYW55IGJ5dGVzIGZvciB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIG9yIGhpdHRpbmcgYSBtYXggYnVmZmVyIHNpemUuXG4gKi9cbmNsYXNzIEludGVyQnl0ZVRpbWVvdXRQYXJzZXIgZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIG1heEJ1ZmZlclNpemU7XG4gICAgY3VycmVudFBhY2tldDtcbiAgICBpbnRlcnZhbDtcbiAgICBpbnRlcnZhbElEO1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4QnVmZmVyU2l6ZSA9IDY1NTM2LCBpbnRlcnZhbCwgLi4udHJhbnNmb3JtT3B0aW9ucyB9KSB7XG4gICAgICAgIHN1cGVyKHRyYW5zZm9ybU9wdGlvbnMpO1xuICAgICAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImludGVydmFsXCIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGludGVydmFsICE9PSAnbnVtYmVyJyB8fCBOdW1iZXIuaXNOYU4oaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImludGVydmFsXCIgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVydmFsIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpbnRlcnZhbFwiIGlzIG5vdCBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWF4QnVmZmVyU2l6ZSAhPT0gJ251bWJlcicgfHwgTnVtYmVyLmlzTmFOKG1heEJ1ZmZlclNpemUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm1heEJ1ZmZlclNpemVcIiBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4QnVmZmVyU2l6ZSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4QnVmZmVyU2l6ZVwiIGlzIG5vdCBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4QnVmZmVyU2l6ZSA9IG1heEJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuY3VycmVudFBhY2tldCA9IFtdO1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElEKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnRlcnZhbElEKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBjaHVuay5sZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWNrZXQucHVzaChjaHVua1tvZmZzZXRdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWNrZXQubGVuZ3RoID49IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBhY2tldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJRCA9IHNldFRpbWVvdXQodGhpcy5lbWl0UGFja2V0LmJpbmQodGhpcyksIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICBjYigpO1xuICAgIH1cbiAgICBlbWl0UGFja2V0KCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElEKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnRlcnZhbElEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGFja2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChCdWZmZXIuZnJvbSh0aGlzLmN1cnJlbnRQYWNrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRQYWNrZXQgPSBbXTtcbiAgICB9XG4gICAgX2ZsdXNoKGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdFBhY2tldCgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJCeXRlVGltZW91dFBhcnNlciA9IEludGVyQnl0ZVRpbWVvdXRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-inter-byte-timeout/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-packet-length/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@serialport/parser-packet-length/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PacketLengthParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that decodes packets with a delimiter and length of payload\n * specified within the data stream.\n * @extends Transform\n * @summary Decodes packets of the general form:\n *       [delimiter][len][payload0] ... [payload0 + len]\n *\n * The length field can be up to 4 bytes and can be at any offset within the packet\n *       [delimiter][header0][header1][len0][len1[payload0] ... [payload0 + len]\n *\n * The offset and number of bytes of the length field need to be provided in options\n * if not 1 byte immediately following the delimiter.\n */\nclass PacketLengthParser extends stream_1.Transform {\n    buffer;\n    start;\n    opts;\n    constructor(options = {}) {\n        super(options);\n        const { delimiter = [0xaa], delimiterBytes = 1, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 0xff } = options;\n        this.opts = {\n            delimiter: [].concat(delimiter),\n            delimiterBytes,\n            packetOverhead,\n            lengthBytes,\n            lengthOffset,\n            maxLen,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            const byte = chunk[ndx];\n            if (true === this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n                if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {\n                    const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);\n                    if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {\n                        this.push(this.buffer);\n                        this.buffer = Buffer.alloc(0);\n                        this.start = false;\n                    }\n                }\n            }\n            else {\n                this.buffer = Buffer.concat([Buffer.from([byte]), this.buffer]);\n                if (this.buffer.length === this.opts.delimiterBytes) {\n                    const delimiter = this.buffer.readUIntLE(0, this.opts.delimiterBytes);\n                    if (this.opts.delimiter.includes(delimiter)) {\n                        this.start = true;\n                        this.buffer = Buffer.from([...this.buffer].reverse());\n                    }\n                    else {\n                        this.buffer = Buffer.from(this.buffer.subarray(1, this.buffer.length));\n                    }\n                }\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.PacketLengthParser = PacketLengthParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXBhY2tldC1sZW5ndGgvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGdCQUFnQiwrR0FBK0c7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L3BhcnNlci1wYWNrZXQtbGVuZ3RoL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhY2tldExlbmd0aFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZGVjb2RlcyBwYWNrZXRzIHdpdGggYSBkZWxpbWl0ZXIgYW5kIGxlbmd0aCBvZiBwYXlsb2FkXG4gKiBzcGVjaWZpZWQgd2l0aGluIHRoZSBkYXRhIHN0cmVhbS5cbiAqIEBleHRlbmRzIFRyYW5zZm9ybVxuICogQHN1bW1hcnkgRGVjb2RlcyBwYWNrZXRzIG9mIHRoZSBnZW5lcmFsIGZvcm06XG4gKiAgICAgICBbZGVsaW1pdGVyXVtsZW5dW3BheWxvYWQwXSAuLi4gW3BheWxvYWQwICsgbGVuXVxuICpcbiAqIFRoZSBsZW5ndGggZmllbGQgY2FuIGJlIHVwIHRvIDQgYnl0ZXMgYW5kIGNhbiBiZSBhdCBhbnkgb2Zmc2V0IHdpdGhpbiB0aGUgcGFja2V0XG4gKiAgICAgICBbZGVsaW1pdGVyXVtoZWFkZXIwXVtoZWFkZXIxXVtsZW4wXVtsZW4xW3BheWxvYWQwXSAuLi4gW3BheWxvYWQwICsgbGVuXVxuICpcbiAqIFRoZSBvZmZzZXQgYW5kIG51bWJlciBvZiBieXRlcyBvZiB0aGUgbGVuZ3RoIGZpZWxkIG5lZWQgdG8gYmUgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICogaWYgbm90IDEgYnl0ZSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIGRlbGltaXRlci5cbiAqL1xuY2xhc3MgUGFja2V0TGVuZ3RoUGFyc2VyIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBidWZmZXI7XG4gICAgc3RhcnQ7XG4gICAgb3B0cztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZGVsaW1pdGVyID0gWzB4YWFdLCBkZWxpbWl0ZXJCeXRlcyA9IDEsIHBhY2tldE92ZXJoZWFkID0gMiwgbGVuZ3RoQnl0ZXMgPSAxLCBsZW5ndGhPZmZzZXQgPSAxLCBtYXhMZW4gPSAweGZmIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm9wdHMgPSB7XG4gICAgICAgICAgICBkZWxpbWl0ZXI6IFtdLmNvbmNhdChkZWxpbWl0ZXIpLFxuICAgICAgICAgICAgZGVsaW1pdGVyQnl0ZXMsXG4gICAgICAgICAgICBwYWNrZXRPdmVyaGVhZCxcbiAgICAgICAgICAgIGxlbmd0aEJ5dGVzLFxuICAgICAgICAgICAgbGVuZ3RoT2Zmc2V0LFxuICAgICAgICAgICAgbWF4TGVuLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgZm9yIChsZXQgbmR4ID0gMDsgbmR4IDwgY2h1bmsubGVuZ3RoOyBuZHgrKykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IGNodW5rW25keF07XG4gICAgICAgICAgICBpZiAodHJ1ZSA9PT0gdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIsIEJ1ZmZlci5mcm9tKFtieXRlXSldKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID49IHRoaXMub3B0cy5sZW5ndGhPZmZzZXQgKyB0aGlzLm9wdHMubGVuZ3RoQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gdGhpcy5idWZmZXIucmVhZFVJbnRMRSh0aGlzLm9wdHMubGVuZ3RoT2Zmc2V0LCB0aGlzLm9wdHMubGVuZ3RoQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09IGxlbiArIHRoaXMub3B0cy5wYWNrZXRPdmVyaGVhZCB8fCBsZW4gPiB0aGlzLm9wdHMubWF4TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2godGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFtieXRlXSksIHRoaXMuYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gdGhpcy5vcHRzLmRlbGltaXRlckJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlciA9IHRoaXMuYnVmZmVyLnJlYWRVSW50TEUoMCwgdGhpcy5vcHRzLmRlbGltaXRlckJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5kZWxpbWl0ZXIuaW5jbHVkZXMoZGVsaW1pdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFsuLi50aGlzLmJ1ZmZlcl0ucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmZyb20odGhpcy5idWZmZXIuc3ViYXJyYXkoMSwgdGhpcy5idWZmZXIubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNiKSB7XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFja2V0TGVuZ3RoUGFyc2VyID0gUGFja2V0TGVuZ3RoUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-packet-length/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-readline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@serialport/parser-readline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadlineParser = void 0;\nconst parser_delimiter_1 = __webpack_require__(/*! @serialport/parser-delimiter */ \"(rsc)/./node_modules/@serialport/parser-delimiter/dist/index.js\");\n/**\n *  A transform stream that emits data after a newline delimiter is received.\n * @summary To use the `Readline` parser, provide a delimiter (defaults to `\\n`). Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n */\nclass ReadlineParser extends parser_delimiter_1.DelimiterParser {\n    constructor(options) {\n        const opts = {\n            delimiter: Buffer.from('\\n', 'utf8'),\n            encoding: 'utf8',\n            ...options,\n        };\n        if (typeof opts.delimiter === 'string') {\n            opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);\n        }\n        super(opts);\n    }\n}\nexports.ReadlineParser = ReadlineParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXJlYWRsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLDJCQUEyQixtQkFBTyxDQUFDLHFHQUE4QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXJlYWRsaW5lL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWRsaW5lUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgcGFyc2VyX2RlbGltaXRlcl8xID0gcmVxdWlyZShcIkBzZXJpYWxwb3J0L3BhcnNlci1kZWxpbWl0ZXJcIik7XG4vKipcbiAqICBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbWl0cyBkYXRhIGFmdGVyIGEgbmV3bGluZSBkZWxpbWl0ZXIgaXMgcmVjZWl2ZWQuXG4gKiBAc3VtbWFyeSBUbyB1c2UgdGhlIGBSZWFkbGluZWAgcGFyc2VyLCBwcm92aWRlIGEgZGVsaW1pdGVyIChkZWZhdWx0cyB0byBgXFxuYCkuIERhdGEgaXMgZW1pdHRlZCBhcyBzdHJpbmcgY29udHJvbGxhYmxlIGJ5IHRoZSBgZW5jb2RpbmdgIG9wdGlvbiAoZGVmYXVsdHMgdG8gYHV0ZjhgKS5cbiAqL1xuY2xhc3MgUmVhZGxpbmVQYXJzZXIgZXh0ZW5kcyBwYXJzZXJfZGVsaW1pdGVyXzEuRGVsaW1pdGVyUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICBkZWxpbWl0ZXI6IEJ1ZmZlci5mcm9tKCdcXG4nLCAndXRmOCcpLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRzLmRlbGltaXRlciA9IEJ1ZmZlci5mcm9tKG9wdHMuZGVsaW1pdGVyLCBvcHRzLmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRsaW5lUGFyc2VyID0gUmVhZGxpbmVQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-readline/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-ready/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@serialport/parser-ready/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadyParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n *\n * To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n */\nclass ReadyParser extends stream_1.Transform {\n    delimiter;\n    readOffset;\n    ready;\n    constructor({ delimiter, ...options }) {\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        super(options);\n        this.delimiter = Buffer.from(delimiter);\n        this.readOffset = 0;\n        this.ready = false;\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.ready) {\n            this.push(chunk);\n            return cb();\n        }\n        const delimiter = this.delimiter;\n        let chunkOffset = 0;\n        while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n            if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n                this.readOffset++;\n            }\n            else {\n                this.readOffset = 0;\n            }\n            chunkOffset++;\n        }\n        if (this.readOffset === delimiter.length) {\n            this.ready = true;\n            this.emit('ready');\n            const chunkRest = chunk.slice(chunkOffset);\n            if (chunkRest.length > 0) {\n                this.push(chunkRest);\n            }\n        }\n        cb();\n    }\n}\nexports.ReadyParser = ReadyParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXJlYWR5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L3BhcnNlci1yZWFkeS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFkeVBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgd2FpdHMgZm9yIGEgc2VxdWVuY2Ugb2YgXCJyZWFkeVwiIGJ5dGVzIGJlZm9yZSBlbWl0dGluZyBhIHJlYWR5IGV2ZW50IGFuZCBlbWl0dGluZyBkYXRhIGV2ZW50c1xuICpcbiAqIFRvIHVzZSB0aGUgYFJlYWR5YCBwYXJzZXIgcHJvdmlkZSBhIGJ5dGUgc3RhcnQgc2VxdWVuY2UuIEFmdGVyIHRoZSBieXRlcyBoYXZlIGJlZW4gcmVjZWl2ZWQgYSByZWFkeSBldmVudCBpcyBmaXJlZCBhbmQgZGF0YSBldmVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLlxuICovXG5jbGFzcyBSZWFkeVBhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgZGVsaW1pdGVyO1xuICAgIHJlYWRPZmZzZXQ7XG4gICAgcmVhZHk7XG4gICAgY29uc3RydWN0b3IoeyBkZWxpbWl0ZXIsIC4uLm9wdGlvbnMgfSkge1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVsaW1pdGVyXCIgaXMgbm90IGEgYnVmZmVyYWJsZSBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWxpbWl0ZXJcIiBoYXMgYSAwIG9yIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBCdWZmZXIuZnJvbShkZWxpbWl0ZXIpO1xuICAgICAgICB0aGlzLnJlYWRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyO1xuICAgICAgICBsZXQgY2h1bmtPZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWFkT2Zmc2V0IDwgZGVsaW1pdGVyLmxlbmd0aCAmJiBjaHVua09mZnNldCA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRlbGltaXRlclt0aGlzLnJlYWRPZmZzZXRdID09PSBjaHVua1tjaHVua09mZnNldF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRPZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZE9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua09mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWRPZmZzZXQgPT09IGRlbGltaXRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmtSZXN0ID0gY2h1bmsuc2xpY2UoY2h1bmtPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNodW5rUmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGNodW5rUmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWR5UGFyc2VyID0gUmVhZHlQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-ready/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-regex/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@serialport/parser-regex/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RegexParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that uses a regular expression to split the incoming text upon.\n *\n * To use the `Regex` parser provide a regular expression to split the incoming text upon. Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n */\nclass RegexParser extends stream_1.Transform {\n    regex;\n    data;\n    constructor({ regex, ...options }) {\n        const opts = {\n            encoding: 'utf8',\n            ...options,\n        };\n        if (regex === undefined) {\n            throw new TypeError('\"options.regex\" must be a regular expression pattern or object');\n        }\n        if (!(regex instanceof RegExp)) {\n            regex = new RegExp(regex.toString());\n        }\n        super(opts);\n        this.regex = regex;\n        this.data = '';\n    }\n    _transform(chunk, encoding, cb) {\n        const data = this.data + chunk;\n        const parts = data.split(this.regex);\n        this.data = parts.pop() || '';\n        parts.forEach(part => {\n            this.push(part);\n        });\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.data);\n        this.data = '';\n        cb();\n    }\n}\nexports.RegexParser = RegexParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXJlZ2V4L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYm91YmVuamFtaW4vZ2l0L3RwLWFybS1yYXNwYmVycnkvbm9kZV9tb2R1bGVzL0BzZXJpYWxwb3J0L3BhcnNlci1yZWdleC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWdleFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgdXNlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCB0aGUgaW5jb21pbmcgdGV4dCB1cG9uLlxuICpcbiAqIFRvIHVzZSB0aGUgYFJlZ2V4YCBwYXJzZXIgcHJvdmlkZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCB0aGUgaW5jb21pbmcgdGV4dCB1cG9uLiBEYXRhIGlzIGVtaXR0ZWQgYXMgc3RyaW5nIGNvbnRyb2xsYWJsZSBieSB0aGUgYGVuY29kaW5nYCBvcHRpb24gKGRlZmF1bHRzIHRvIGB1dGY4YCkuXG4gKi9cbmNsYXNzIFJlZ2V4UGFyc2VyIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICByZWdleDtcbiAgICBkYXRhO1xuICAgIGNvbnN0cnVjdG9yKHsgcmVnZXgsIC4uLm9wdGlvbnMgfSkge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMucmVnZXhcIiBtdXN0IGJlIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gb3Igb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVnZXggaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXgudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICAgICAgdGhpcy5kYXRhID0gJyc7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhICsgY2h1bms7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZGF0YS5zcGxpdCh0aGlzLnJlZ2V4KTtcbiAgICAgICAgdGhpcy5kYXRhID0gcGFydHMucG9wKCkgfHwgJyc7XG4gICAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYigpO1xuICAgIH1cbiAgICBfZmx1c2goY2IpIHtcbiAgICAgICAgdGhpcy5wdXNoKHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMuZGF0YSA9ICcnO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVnZXhQYXJzZXIgPSBSZWdleFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-regex/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/decoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@serialport/parser-slip-encoder/dist/decoder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SlipDecoder = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that decodes slip encoded data.\n * @extends Transform\n *\n * Runs in O(n) time, stripping out slip encoding and emitting decoded data. Optionally custom slip escape and delimiters can be provided.\n */\nclass SlipDecoder extends stream_1.Transform {\n    opts;\n    buffer;\n    escape;\n    start;\n    constructor(options = {}) {\n        super(options);\n        const { START, ESC = 0xdb, END = 0xc0, ESC_START, ESC_END = 0xdc, ESC_ESC = 0xdd } = options;\n        this.opts = {\n            START,\n            ESC,\n            END,\n            ESC_START,\n            ESC_END,\n            ESC_ESC,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.escape = false;\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            let byte = chunk[ndx];\n            if (byte === this.opts.START) {\n                this.start = true;\n                continue;\n            }\n            else if (undefined == this.opts.START) {\n                this.start = true;\n            }\n            if (this.escape) {\n                if (byte === this.opts.ESC_START && this.opts.START) {\n                    byte = this.opts.START;\n                }\n                else if (byte === this.opts.ESC_ESC) {\n                    byte = this.opts.ESC;\n                }\n                else if (byte === this.opts.ESC_END) {\n                    byte = this.opts.END;\n                }\n                else {\n                    this.escape = false;\n                    this.push(this.buffer);\n                    this.buffer = Buffer.alloc(0);\n                }\n            }\n            else {\n                if (byte === this.opts.ESC) {\n                    this.escape = true;\n                    continue;\n                }\n                if (byte === this.opts.END) {\n                    this.push(this.buffer);\n                    this.buffer = Buffer.alloc(0);\n                    this.escape = false;\n                    this.start = false;\n                    continue;\n                }\n            }\n            this.escape = false;\n            if (this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.SlipDecoder = SlipDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNsaXAtZW5jb2Rlci9kaXN0L2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxnQkFBZ0IsMkVBQTJFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNsaXAtZW5jb2Rlci9kaXN0L2RlY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNsaXBEZWNvZGVyID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLyoqXG4gKiBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBkZWNvZGVzIHNsaXAgZW5jb2RlZCBkYXRhLlxuICogQGV4dGVuZHMgVHJhbnNmb3JtXG4gKlxuICogUnVucyBpbiBPKG4pIHRpbWUsIHN0cmlwcGluZyBvdXQgc2xpcCBlbmNvZGluZyBhbmQgZW1pdHRpbmcgZGVjb2RlZCBkYXRhLiBPcHRpb25hbGx5IGN1c3RvbSBzbGlwIGVzY2FwZSBhbmQgZGVsaW1pdGVycyBjYW4gYmUgcHJvdmlkZWQuXG4gKi9cbmNsYXNzIFNsaXBEZWNvZGVyIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBvcHRzO1xuICAgIGJ1ZmZlcjtcbiAgICBlc2NhcGU7XG4gICAgc3RhcnQ7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IFNUQVJULCBFU0MgPSAweGRiLCBFTkQgPSAweGMwLCBFU0NfU1RBUlQsIEVTQ19FTkQgPSAweGRjLCBFU0NfRVNDID0gMHhkZCB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAgICAgU1RBUlQsXG4gICAgICAgICAgICBFU0MsXG4gICAgICAgICAgICBFTkQsXG4gICAgICAgICAgICBFU0NfU1RBUlQsXG4gICAgICAgICAgICBFU0NfRU5ELFxuICAgICAgICAgICAgRVNDX0VTQyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGZvciAobGV0IG5keCA9IDA7IG5keCA8IGNodW5rLmxlbmd0aDsgbmR4KyspIHtcbiAgICAgICAgICAgIGxldCBieXRlID0gY2h1bmtbbmR4XTtcbiAgICAgICAgICAgIGlmIChieXRlID09PSB0aGlzLm9wdHMuU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVuZGVmaW5lZCA9PSB0aGlzLm9wdHMuU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVzY2FwZSkge1xuICAgICAgICAgICAgICAgIGlmIChieXRlID09PSB0aGlzLm9wdHMuRVNDX1NUQVJUICYmIHRoaXMub3B0cy5TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlID0gdGhpcy5vcHRzLlNUQVJUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieXRlID09PSB0aGlzLm9wdHMuRVNDX0VTQykge1xuICAgICAgICAgICAgICAgICAgICBieXRlID0gdGhpcy5vcHRzLkVTQztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZSA9PT0gdGhpcy5vcHRzLkVTQ19FTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZSA9IHRoaXMub3B0cy5FTkQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2godGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZSA9PT0gdGhpcy5vcHRzLkVTQykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZSA9PT0gdGhpcy5vcHRzLkVORCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2godGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmZmVyLCBCdWZmZXIuZnJvbShbYnl0ZV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNiKSB7XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2xpcERlY29kZXIgPSBTbGlwRGVjb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/encoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@serialport/parser-slip-encoder/dist/encoder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SlipEncoder = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A transform stream that emits SLIP-encoded data for each incoming packet.\n *\n * Runs in O(n) time, adding a 0xC0 character at the end of each\n * received packet and escaping characters, according to RFC 1055.\n */\nclass SlipEncoder extends stream_1.Transform {\n    opts;\n    constructor(options = {}) {\n        super(options);\n        const { START, ESC = 0xdb, END = 0xc0, ESC_START, ESC_END = 0xdc, ESC_ESC = 0xdd, bluetoothQuirk = false } = options;\n        this.opts = {\n            START,\n            ESC,\n            END,\n            ESC_START,\n            ESC_END,\n            ESC_ESC,\n            bluetoothQuirk,\n        };\n    }\n    _transform(chunk, encoding, cb) {\n        const chunkLength = chunk.length;\n        if (this.opts.bluetoothQuirk && chunkLength === 0) {\n            // Edge case: push no data. Bluetooth-quirky SLIP parsers don't like\n            // lots of 0xC0s together.\n            return cb();\n        }\n        // Allocate memory for the worst-case scenario: all bytes are escaped,\n        // plus start and end separators.\n        const encoded = Buffer.alloc(chunkLength * 2 + 2);\n        let j = 0;\n        if (this.opts.bluetoothQuirk == true) {\n            encoded[j++] = this.opts.END;\n        }\n        if (this.opts.START !== undefined) {\n            encoded[j++] = this.opts.START;\n        }\n        for (let i = 0; i < chunkLength; i++) {\n            let byte = chunk[i];\n            if (byte === this.opts.START && this.opts.ESC_START) {\n                encoded[j++] = this.opts.ESC;\n                byte = this.opts.ESC_START;\n            }\n            else if (byte === this.opts.END) {\n                encoded[j++] = this.opts.ESC;\n                byte = this.opts.ESC_END;\n            }\n            else if (byte === this.opts.ESC) {\n                encoded[j++] = this.opts.ESC;\n                byte = this.opts.ESC_ESC;\n            }\n            encoded[j++] = byte;\n        }\n        encoded[j++] = this.opts.END;\n        cb(null, encoded.slice(0, j));\n    }\n}\nexports.SlipEncoder = SlipEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNsaXAtZW5jb2Rlci9kaXN0L2VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxnQkFBZ0IsbUdBQW1HO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItc2xpcC1lbmNvZGVyL2Rpc3QvZW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2xpcEVuY29kZXIgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4vKipcbiAqIEEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVtaXRzIFNMSVAtZW5jb2RlZCBkYXRhIGZvciBlYWNoIGluY29taW5nIHBhY2tldC5cbiAqXG4gKiBSdW5zIGluIE8obikgdGltZSwgYWRkaW5nIGEgMHhDMCBjaGFyYWN0ZXIgYXQgdGhlIGVuZCBvZiBlYWNoXG4gKiByZWNlaXZlZCBwYWNrZXQgYW5kIGVzY2FwaW5nIGNoYXJhY3RlcnMsIGFjY29yZGluZyB0byBSRkMgMTA1NS5cbiAqL1xuY2xhc3MgU2xpcEVuY29kZXIgZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIG9wdHM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IFNUQVJULCBFU0MgPSAweGRiLCBFTkQgPSAweGMwLCBFU0NfU1RBUlQsIEVTQ19FTkQgPSAweGRjLCBFU0NfRVNDID0gMHhkZCwgYmx1ZXRvb3RoUXVpcmsgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAgICAgU1RBUlQsXG4gICAgICAgICAgICBFU0MsXG4gICAgICAgICAgICBFTkQsXG4gICAgICAgICAgICBFU0NfU1RBUlQsXG4gICAgICAgICAgICBFU0NfRU5ELFxuICAgICAgICAgICAgRVNDX0VTQyxcbiAgICAgICAgICAgIGJsdWV0b290aFF1aXJrLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgY29uc3QgY2h1bmtMZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYmx1ZXRvb3RoUXVpcmsgJiYgY2h1bmtMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEVkZ2UgY2FzZTogcHVzaCBubyBkYXRhLiBCbHVldG9vdGgtcXVpcmt5IFNMSVAgcGFyc2VycyBkb24ndCBsaWtlXG4gICAgICAgICAgICAvLyBsb3RzIG9mIDB4QzBzIHRvZ2V0aGVyLlxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgbWVtb3J5IGZvciB0aGUgd29yc3QtY2FzZSBzY2VuYXJpbzogYWxsIGJ5dGVzIGFyZSBlc2NhcGVkLFxuICAgICAgICAvLyBwbHVzIHN0YXJ0IGFuZCBlbmQgc2VwYXJhdG9ycy5cbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IEJ1ZmZlci5hbGxvYyhjaHVua0xlbmd0aCAqIDIgKyAyKTtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmJsdWV0b290aFF1aXJrID09IHRydWUpIHtcbiAgICAgICAgICAgIGVuY29kZWRbaisrXSA9IHRoaXMub3B0cy5FTkQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5TVEFSVCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmNvZGVkW2orK10gPSB0aGlzLm9wdHMuU1RBUlQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZSA9IGNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKGJ5dGUgPT09IHRoaXMub3B0cy5TVEFSVCAmJiB0aGlzLm9wdHMuRVNDX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFtqKytdID0gdGhpcy5vcHRzLkVTQztcbiAgICAgICAgICAgICAgICBieXRlID0gdGhpcy5vcHRzLkVTQ19TVEFSVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGUgPT09IHRoaXMub3B0cy5FTkQpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkW2orK10gPSB0aGlzLm9wdHMuRVNDO1xuICAgICAgICAgICAgICAgIGJ5dGUgPSB0aGlzLm9wdHMuRVNDX0VORDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGUgPT09IHRoaXMub3B0cy5FU0MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkW2orK10gPSB0aGlzLm9wdHMuRVNDO1xuICAgICAgICAgICAgICAgIGJ5dGUgPSB0aGlzLm9wdHMuRVNDX0VTQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuY29kZWRbaisrXSA9IGJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZFtqKytdID0gdGhpcy5vcHRzLkVORDtcbiAgICAgICAgY2IobnVsbCwgZW5jb2RlZC5zbGljZSgwLCBqKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TbGlwRW5jb2RlciA9IFNsaXBFbmNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/encoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@serialport/parser-slip-encoder/dist/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./decoder */ \"(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/decoder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encoder */ \"(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/encoder.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNsaXAtZW5jb2Rlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx1RkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsdUZBQVciLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItc2xpcC1lbmNvZGVyL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kZWNvZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNvZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-slip-encoder/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-spacepacket/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@serialport/parser-spacepacket/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpacePacketParser = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@serialport/parser-spacepacket/dist/utils.js\");\n/**\n * A Transform stream that accepts a stream of octet data and converts it into an object\n * representation of a CCSDS Space Packet. See https://public.ccsds.org/Pubs/133x0b2e1.pdf for a\n * description of the Space Packet format.\n */\nclass SpacePacketParser extends stream_1.Transform {\n    timeCodeFieldLength;\n    ancillaryDataFieldLength;\n    dataBuffer;\n    headerBuffer;\n    dataLength;\n    expectingHeader;\n    dataSlice;\n    header;\n    /**\n     * A Transform stream that accepts a stream of octet data and emits object representations of\n     * CCSDS Space Packets once a packet has been completely received.\n     * @param {Object} [options] Configuration options for the stream\n     * @param {Number} options.timeCodeFieldLength The length of the time code field within the data\n     * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data\n     */\n    constructor(options = {}) {\n        super({ ...options, objectMode: true });\n        // Set the constants for this Space Packet Connection; these will help us parse incoming data\n        // fields:\n        this.timeCodeFieldLength = options.timeCodeFieldLength || 0;\n        this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;\n        this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;\n        // These are stateful based on the current packet being received:\n        this.dataBuffer = Buffer.alloc(0);\n        this.headerBuffer = Buffer.alloc(0);\n        this.dataLength = 0;\n        this.expectingHeader = true;\n    }\n    /**\n     * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.\n     * If more data has been received past the current packet, begin the process of parsing the next\n     * packet(s).\n     */\n    pushCompletedPacket() {\n        if (!this.header) {\n            throw new Error('Missing header');\n        }\n        const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));\n        const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));\n        const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));\n        const completedPacket = {\n            header: { ...this.header },\n            data: data.toString(),\n        };\n        if (timeCode.length > 0 || ancillaryData.length > 0) {\n            completedPacket.secondaryHeader = {};\n            if (timeCode.length) {\n                completedPacket.secondaryHeader.timeCode = timeCode.toString();\n            }\n            if (ancillaryData.length) {\n                completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();\n            }\n        }\n        this.push(completedPacket);\n        // If there is an overflow (i.e. we have more data than the packet we just pushed) begin parsing\n        // the next packet.\n        const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));\n        if (nextChunk.length >= utils_1.HEADER_LENGTH) {\n            this.extractHeader(nextChunk);\n        }\n        else {\n            this.headerBuffer = nextChunk;\n            this.dataBuffer = Buffer.alloc(0);\n            this.expectingHeader = true;\n            this.dataLength = 0;\n            this.header = undefined;\n        }\n    }\n    /**\n     * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it\n     * if it's complete. If there's more to the chunk than just the header, initiate handling the\n     * packet data.\n     * @param chunk -  Build the Stream's headerBuffer property from\n     */\n    extractHeader(chunk) {\n        const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);\n        const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);\n        if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {\n            this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);\n            this.dataLength = this.header.dataLength;\n            this.headerBuffer = Buffer.alloc(0);\n            this.expectingHeader = false;\n        }\n        else {\n            this.headerBuffer = headerAsBuffer;\n        }\n        if (startOfDataBuffer.length > 0) {\n            this.dataBuffer = Buffer.from(startOfDataBuffer);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.expectingHeader) {\n            this.extractHeader(chunk);\n        }\n        else {\n            this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);\n        const remainingArray = Array.from(remaining);\n        this.push(remainingArray);\n        cb();\n    }\n}\nexports.SpacePacketParser = SpacePacketParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNwYWNlcGFja2V0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDRCQUE0QjtBQUM1QixnQkFBZ0IsOEJBQThCO0FBQzlDLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNwYWNlcGFja2V0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNwYWNlUGFja2V0UGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIFRyYW5zZm9ybSBzdHJlYW0gdGhhdCBhY2NlcHRzIGEgc3RyZWFtIG9mIG9jdGV0IGRhdGEgYW5kIGNvbnZlcnRzIGl0IGludG8gYW4gb2JqZWN0XG4gKiByZXByZXNlbnRhdGlvbiBvZiBhIENDU0RTIFNwYWNlIFBhY2tldC4gU2VlIGh0dHBzOi8vcHVibGljLmNjc2RzLm9yZy9QdWJzLzEzM3gwYjJlMS5wZGYgZm9yIGFcbiAqIGRlc2NyaXB0aW9uIG9mIHRoZSBTcGFjZSBQYWNrZXQgZm9ybWF0LlxuICovXG5jbGFzcyBTcGFjZVBhY2tldFBhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgdGltZUNvZGVGaWVsZExlbmd0aDtcbiAgICBhbmNpbGxhcnlEYXRhRmllbGRMZW5ndGg7XG4gICAgZGF0YUJ1ZmZlcjtcbiAgICBoZWFkZXJCdWZmZXI7XG4gICAgZGF0YUxlbmd0aDtcbiAgICBleHBlY3RpbmdIZWFkZXI7XG4gICAgZGF0YVNsaWNlO1xuICAgIGhlYWRlcjtcbiAgICAvKipcbiAgICAgKiBBIFRyYW5zZm9ybSBzdHJlYW0gdGhhdCBhY2NlcHRzIGEgc3RyZWFtIG9mIG9jdGV0IGRhdGEgYW5kIGVtaXRzIG9iamVjdCByZXByZXNlbnRhdGlvbnMgb2ZcbiAgICAgKiBDQ1NEUyBTcGFjZSBQYWNrZXRzIG9uY2UgYSBwYWNrZXQgaGFzIGJlZW4gY29tcGxldGVseSByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnRpbWVDb2RlRmllbGRMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgdGltZSBjb2RlIGZpZWxkIHdpdGhpbiB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFuY2lsbGFyeURhdGFGaWVsZExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBhbmNpbGxhcnkgZGF0YSBmaWVsZCB3aXRoaW4gdGhlIGRhdGFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoeyAuLi5vcHRpb25zLCBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICAvLyBTZXQgdGhlIGNvbnN0YW50cyBmb3IgdGhpcyBTcGFjZSBQYWNrZXQgQ29ubmVjdGlvbjsgdGhlc2Ugd2lsbCBoZWxwIHVzIHBhcnNlIGluY29taW5nIGRhdGFcbiAgICAgICAgLy8gZmllbGRzOlxuICAgICAgICB0aGlzLnRpbWVDb2RlRmllbGRMZW5ndGggPSBvcHRpb25zLnRpbWVDb2RlRmllbGRMZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5hbmNpbGxhcnlEYXRhRmllbGRMZW5ndGggPSBvcHRpb25zLmFuY2lsbGFyeURhdGFGaWVsZExlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLmRhdGFTbGljZSA9IHRoaXMudGltZUNvZGVGaWVsZExlbmd0aCArIHRoaXMuYW5jaWxsYXJ5RGF0YUZpZWxkTGVuZ3RoO1xuICAgICAgICAvLyBUaGVzZSBhcmUgc3RhdGVmdWwgYmFzZWQgb24gdGhlIGN1cnJlbnQgcGFja2V0IGJlaW5nIHJlY2VpdmVkOlxuICAgICAgICB0aGlzLmRhdGFCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMuaGVhZGVyQnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmV4cGVjdGluZ0hlYWRlciA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1bmRsZSB0aGUgaGVhZGVyLCBzZWNvbmRhcnkgaGVhZGVyIGlmIHByZXNlbnQsIGFuZCB0aGUgZGF0YSBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gZW1pdC5cbiAgICAgKiBJZiBtb3JlIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgcGFzdCB0aGUgY3VycmVudCBwYWNrZXQsIGJlZ2luIHRoZSBwcm9jZXNzIG9mIHBhcnNpbmcgdGhlIG5leHRcbiAgICAgKiBwYWNrZXQocykuXG4gICAgICovXG4gICAgcHVzaENvbXBsZXRlZFBhY2tldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVDb2RlID0gQnVmZmVyLmZyb20odGhpcy5kYXRhQnVmZmVyLnNsaWNlKDAsIHRoaXMudGltZUNvZGVGaWVsZExlbmd0aCkpO1xuICAgICAgICBjb25zdCBhbmNpbGxhcnlEYXRhID0gQnVmZmVyLmZyb20odGhpcy5kYXRhQnVmZmVyLnNsaWNlKHRoaXMudGltZUNvZGVGaWVsZExlbmd0aCwgdGhpcy50aW1lQ29kZUZpZWxkTGVuZ3RoICsgdGhpcy5hbmNpbGxhcnlEYXRhRmllbGRMZW5ndGgpKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKHRoaXMuZGF0YUJ1ZmZlci5zbGljZSh0aGlzLmRhdGFTbGljZSwgdGhpcy5kYXRhTGVuZ3RoKSk7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZFBhY2tldCA9IHtcbiAgICAgICAgICAgIGhlYWRlcjogeyAuLi50aGlzLmhlYWRlciB9LFxuICAgICAgICAgICAgZGF0YTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGltZUNvZGUubGVuZ3RoID4gMCB8fCBhbmNpbGxhcnlEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZFBhY2tldC5zZWNvbmRhcnlIZWFkZXIgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aW1lQ29kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRQYWNrZXQuc2Vjb25kYXJ5SGVhZGVyLnRpbWVDb2RlID0gdGltZUNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmNpbGxhcnlEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFBhY2tldC5zZWNvbmRhcnlIZWFkZXIuYW5jaWxsYXJ5RGF0YSA9IGFuY2lsbGFyeURhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2goY29tcGxldGVkUGFja2V0KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gb3ZlcmZsb3cgKGkuZS4gd2UgaGF2ZSBtb3JlIGRhdGEgdGhhbiB0aGUgcGFja2V0IHdlIGp1c3QgcHVzaGVkKSBiZWdpbiBwYXJzaW5nXG4gICAgICAgIC8vIHRoZSBuZXh0IHBhY2tldC5cbiAgICAgICAgY29uc3QgbmV4dENodW5rID0gQnVmZmVyLmZyb20odGhpcy5kYXRhQnVmZmVyLnNsaWNlKHRoaXMuZGF0YUxlbmd0aCkpO1xuICAgICAgICBpZiAobmV4dENodW5rLmxlbmd0aCA+PSB1dGlsc18xLkhFQURFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdEhlYWRlcihuZXh0Q2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJCdWZmZXIgPSBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmRhdGFCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdGluZ0hlYWRlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIFN0cmVhbSdzIGhlYWRlckJ1ZmZlciBwcm9wZXJ0eSBmcm9tIHRoZSByZWNlaXZlZCBCdWZmZXIgY2h1bms7IGV4dHJhY3QgZGF0YSBmcm9tIGl0XG4gICAgICogaWYgaXQncyBjb21wbGV0ZS4gSWYgdGhlcmUncyBtb3JlIHRvIHRoZSBjaHVuayB0aGFuIGp1c3QgdGhlIGhlYWRlciwgaW5pdGlhdGUgaGFuZGxpbmcgdGhlXG4gICAgICogcGFja2V0IGRhdGEuXG4gICAgICogQHBhcmFtIGNodW5rIC0gIEJ1aWxkIHRoZSBTdHJlYW0ncyBoZWFkZXJCdWZmZXIgcHJvcGVydHkgZnJvbVxuICAgICAqL1xuICAgIGV4dHJhY3RIZWFkZXIoY2h1bmspIHtcbiAgICAgICAgY29uc3QgaGVhZGVyQXNCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlckJ1ZmZlciwgY2h1bmtdKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZkRhdGFCdWZmZXIgPSBoZWFkZXJBc0J1ZmZlci5zbGljZSh1dGlsc18xLkhFQURFUl9MRU5HVEgpO1xuICAgICAgICBpZiAoaGVhZGVyQXNCdWZmZXIubGVuZ3RoID49IHV0aWxzXzEuSEVBREVSX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXIgPSAoMCwgdXRpbHNfMS5jb252ZXJ0SGVhZGVyQnVmZmVyVG9PYmopKGhlYWRlckFzQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxlbmd0aCA9IHRoaXMuaGVhZGVyLmRhdGFMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0aW5nSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckJ1ZmZlciA9IGhlYWRlckFzQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE9mRGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFCdWZmZXIgPSBCdWZmZXIuZnJvbShzdGFydE9mRGF0YUJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhQnVmZmVyLmxlbmd0aCA+PSB0aGlzLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hDb21wbGV0ZWRQYWNrZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0aW5nSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhY3RIZWFkZXIoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5kYXRhQnVmZmVyLCBjaHVua10pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUJ1ZmZlci5sZW5ndGggPj0gdGhpcy5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoQ29tcGxldGVkUGFja2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNiKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyQnVmZmVyLCB0aGlzLmRhdGFCdWZmZXJdKTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nQXJyYXkgPSBBcnJheS5mcm9tKHJlbWFpbmluZyk7XG4gICAgICAgIHRoaXMucHVzaChyZW1haW5pbmdBcnJheSk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TcGFjZVBhY2tldFBhcnNlciA9IFNwYWNlUGFja2V0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-spacepacket/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/parser-spacepacket/dist/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@serialport/parser-spacepacket/dist/utils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertHeaderBufferToObj = exports.HEADER_LENGTH = void 0;\nexports.HEADER_LENGTH = 6;\n/**\n * For numbers less than 255, will ensure that their string representation is at least 8 characters long.\n */\nconst toOctetStr = (num) => {\n    let str = Number(num).toString(2);\n    while (str.length < 8) {\n        str = `0${str}`;\n    }\n    return str;\n};\n/**\n * Converts a Buffer of any length to an Object representation of a Space Packet header, provided\n * the received data is in the correct format.\n * @param buf - The buffer containing the Space Packet Header Data\n */\nconst convertHeaderBufferToObj = (buf) => {\n    const headerStr = Array.from(buf.slice(0, exports.HEADER_LENGTH)).reduce((accum, curr) => `${accum}${toOctetStr(curr)}`, '');\n    const isVersion1 = headerStr.slice(0, 3) === '000';\n    const versionNumber = isVersion1 ? 1 : 'UNKNOWN_VERSION';\n    const type = Number(headerStr[3]);\n    const secondaryHeader = Number(headerStr[4]);\n    const apid = parseInt(headerStr.slice(5, 16), 2);\n    const sequenceFlags = parseInt(headerStr.slice(16, 18), 2);\n    const packetName = parseInt(headerStr.slice(18, 32), 2);\n    const dataLength = parseInt(headerStr.slice(-16), 2) + 1;\n    return {\n        versionNumber,\n        identification: {\n            apid,\n            secondaryHeader,\n            type,\n        },\n        sequenceControl: {\n            packetName,\n            sequenceFlags,\n        },\n        dataLength,\n    };\n};\nexports.convertHeaderBufferToObj = convertHeaderBufferToObj;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvcGFyc2VyLXNwYWNlcGFja2V0L2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcscUJBQXFCO0FBQ3hELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsTUFBTSxFQUFFLGlCQUFpQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWJvdWJlbmphbWluL2dpdC90cC1hcm0tcmFzcGJlcnJ5L25vZGVfbW9kdWxlcy9Ac2VyaWFscG9ydC9wYXJzZXItc3BhY2VwYWNrZXQvZGlzdC91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udmVydEhlYWRlckJ1ZmZlclRvT2JqID0gZXhwb3J0cy5IRUFERVJfTEVOR1RIID0gdm9pZCAwO1xuZXhwb3J0cy5IRUFERVJfTEVOR1RIID0gNjtcbi8qKlxuICogRm9yIG51bWJlcnMgbGVzcyB0aGFuIDI1NSwgd2lsbCBlbnN1cmUgdGhhdCB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIGxvbmcuXG4gKi9cbmNvbnN0IHRvT2N0ZXRTdHIgPSAobnVtKSA9PiB7XG4gICAgbGV0IHN0ciA9IE51bWJlcihudW0pLnRvU3RyaW5nKDIpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgOCkge1xuICAgICAgICBzdHIgPSBgMCR7c3RyfWA7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIEJ1ZmZlciBvZiBhbnkgbGVuZ3RoIHRvIGFuIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIFNwYWNlIFBhY2tldCBoZWFkZXIsIHByb3ZpZGVkXG4gKiB0aGUgcmVjZWl2ZWQgZGF0YSBpcyBpbiB0aGUgY29ycmVjdCBmb3JtYXQuXG4gKiBAcGFyYW0gYnVmIC0gVGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBTcGFjZSBQYWNrZXQgSGVhZGVyIERhdGFcbiAqL1xuY29uc3QgY29udmVydEhlYWRlckJ1ZmZlclRvT2JqID0gKGJ1ZikgPT4ge1xuICAgIGNvbnN0IGhlYWRlclN0ciA9IEFycmF5LmZyb20oYnVmLnNsaWNlKDAsIGV4cG9ydHMuSEVBREVSX0xFTkdUSCkpLnJlZHVjZSgoYWNjdW0sIGN1cnIpID0+IGAke2FjY3VtfSR7dG9PY3RldFN0cihjdXJyKX1gLCAnJyk7XG4gICAgY29uc3QgaXNWZXJzaW9uMSA9IGhlYWRlclN0ci5zbGljZSgwLCAzKSA9PT0gJzAwMCc7XG4gICAgY29uc3QgdmVyc2lvbk51bWJlciA9IGlzVmVyc2lvbjEgPyAxIDogJ1VOS05PV05fVkVSU0lPTic7XG4gICAgY29uc3QgdHlwZSA9IE51bWJlcihoZWFkZXJTdHJbM10pO1xuICAgIGNvbnN0IHNlY29uZGFyeUhlYWRlciA9IE51bWJlcihoZWFkZXJTdHJbNF0pO1xuICAgIGNvbnN0IGFwaWQgPSBwYXJzZUludChoZWFkZXJTdHIuc2xpY2UoNSwgMTYpLCAyKTtcbiAgICBjb25zdCBzZXF1ZW5jZUZsYWdzID0gcGFyc2VJbnQoaGVhZGVyU3RyLnNsaWNlKDE2LCAxOCksIDIpO1xuICAgIGNvbnN0IHBhY2tldE5hbWUgPSBwYXJzZUludChoZWFkZXJTdHIuc2xpY2UoMTgsIDMyKSwgMik7XG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IHBhcnNlSW50KGhlYWRlclN0ci5zbGljZSgtMTYpLCAyKSArIDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbk51bWJlcixcbiAgICAgICAgaWRlbnRpZmljYXRpb246IHtcbiAgICAgICAgICAgIGFwaWQsXG4gICAgICAgICAgICBzZWNvbmRhcnlIZWFkZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9LFxuICAgICAgICBzZXF1ZW5jZUNvbnRyb2w6IHtcbiAgICAgICAgICAgIHBhY2tldE5hbWUsXG4gICAgICAgICAgICBzZXF1ZW5jZUZsYWdzLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGVuZ3RoLFxuICAgIH07XG59O1xuZXhwb3J0cy5jb252ZXJ0SGVhZGVyQnVmZmVyVG9PYmogPSBjb252ZXJ0SGVhZGVyQnVmZmVyVG9PYmo7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/parser-spacepacket/dist/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@serialport/stream/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@serialport/stream/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SerialPortStream = exports.DisconnectedError = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)('serialport/stream');\nclass DisconnectedError extends Error {\n    disconnected;\n    constructor(message) {\n        super(message);\n        this.disconnected = true;\n    }\n}\nexports.DisconnectedError = DisconnectedError;\nconst defaultSetFlags = {\n    brk: false,\n    cts: false,\n    dtr: true,\n    rts: true,\n};\nfunction allocNewReadPool(poolSize) {\n    const pool = Buffer.allocUnsafe(poolSize);\n    pool.used = 0;\n    return pool;\n}\nclass SerialPortStream extends stream_1.Duplex {\n    port;\n    _pool;\n    _kMinPoolSpace;\n    opening;\n    closing;\n    settings;\n    /**\n     * Create a new serial port object for the `path`. In the case of invalid arguments or invalid options, when constructing a new SerialPort it will throw an error. The port will open automatically by default, which is the equivalent of calling `port.open(openCallback)` in the next tick. You can disable this by setting the option `autoOpen` to `false`.\n     * @emits open\n     * @emits data\n     * @emits close\n     * @emits error\n     */\n    constructor(options, openCallback) {\n        const settings = {\n            autoOpen: true,\n            endOnClose: false,\n            highWaterMark: 64 * 1024,\n            ...options,\n        };\n        super({\n            highWaterMark: settings.highWaterMark,\n        });\n        if (!settings.binding) {\n            throw new TypeError('\"Bindings\" is invalid pass it as `options.binding`');\n        }\n        if (!settings.path) {\n            throw new TypeError(`\"path\" is not defined: ${settings.path}`);\n        }\n        if (typeof settings.baudRate !== 'number') {\n            throw new TypeError(`\"baudRate\" must be a number: ${settings.baudRate}`);\n        }\n        this.settings = settings;\n        this.opening = false;\n        this.closing = false;\n        this._pool = allocNewReadPool(this.settings.highWaterMark);\n        this._kMinPoolSpace = 128;\n        if (this.settings.autoOpen) {\n            this.open(openCallback);\n        }\n    }\n    get path() {\n        return this.settings.path;\n    }\n    get baudRate() {\n        return this.settings.baudRate;\n    }\n    get isOpen() {\n        return (this.port?.isOpen ?? false) && !this.closing;\n    }\n    _error(error, callback) {\n        if (callback) {\n            callback.call(this, error);\n        }\n        else {\n            this.emit('error', error);\n        }\n    }\n    _asyncError(error, callback) {\n        process.nextTick(() => this._error(error, callback));\n    }\n    /**\n     * Opens a connection to the given serial port.\n     * @param {ErrorCallback=} openCallback - Called after a connection is opened. If this is not provided and an error occurs, it will be emitted on the port's `error` event.\n     * @emits open\n     */\n    open(openCallback) {\n        if (this.isOpen) {\n            return this._asyncError(new Error('Port is already open'), openCallback);\n        }\n        if (this.opening) {\n            return this._asyncError(new Error('Port is opening'), openCallback);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { highWaterMark, binding, autoOpen, endOnClose, ...openOptions } = this.settings;\n        this.opening = true;\n        debug('opening', `path: ${this.path}`);\n        this.settings.binding.open(openOptions).then(port => {\n            debug('opened', `path: ${this.path}`);\n            this.port = port;\n            this.opening = false;\n            this.emit('open');\n            if (openCallback) {\n                openCallback.call(this, null);\n            }\n        }, err => {\n            this.opening = false;\n            debug('Binding #open had an error', err);\n            this._error(err, openCallback);\n        });\n    }\n    /**\n     * Changes the baud rate for an open port. Emits an error or calls the callback if the baud rate isn't supported.\n     * @param {object=} options Only supports `baudRate`.\n     * @param {number=} [options.baudRate] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.\n     * @param {ErrorCallback=} [callback] Called once the port's baud rate changes. If `.update` is called without a callback, and there is an error, an error event is emitted.\n     * @returns {undefined}\n     */\n    update(options, callback) {\n        if (!this.isOpen || !this.port) {\n            debug('update attempted, but port is not open');\n            return this._asyncError(new Error('Port is not open'), callback);\n        }\n        debug('update', `baudRate: ${options.baudRate}`);\n        this.port.update(options).then(() => {\n            debug('binding.update', 'finished');\n            this.settings.baudRate = options.baudRate;\n            if (callback) {\n                callback.call(this, null);\n            }\n        }, err => {\n            debug('binding.update', 'error', err);\n            return this._error(err, callback);\n        });\n    }\n    write(data, encoding, callback) {\n        if (Array.isArray(data)) {\n            data = Buffer.from(data);\n        }\n        if (typeof encoding === 'function') {\n            return super.write(data, encoding);\n        }\n        return super.write(data, encoding, callback);\n    }\n    _write(data, encoding, callback) {\n        if (!this.isOpen || !this.port) {\n            this.once('open', () => {\n                this._write(data, encoding, callback);\n            });\n            return;\n        }\n        debug('_write', `${data.length} bytes of data`);\n        this.port.write(data).then(() => {\n            debug('binding.write', 'write finished');\n            callback(null);\n        }, err => {\n            debug('binding.write', 'error', err);\n            if (!err.canceled) {\n                this._disconnected(err);\n            }\n            callback(err);\n        });\n    }\n    _writev(data, callback) {\n        debug('_writev', `${data.length} chunks of data`);\n        const dataV = data.map(write => write.chunk);\n        this._write(Buffer.concat(dataV), 'binary', callback);\n    }\n    _read(bytesToRead) {\n        if (!this.isOpen || !this.port) {\n            debug('_read', 'queueing _read for after open');\n            this.once('open', () => {\n                this._read(bytesToRead);\n            });\n            return;\n        }\n        if (!this._pool || this._pool.length - this._pool.used < this._kMinPoolSpace) {\n            debug('_read', 'discarding the read buffer pool because it is below kMinPoolSpace');\n            this._pool = allocNewReadPool(this.settings.highWaterMark);\n        }\n        // Grab another reference to the pool in the case that while we're\n        // in the thread pool another read() finishes up the pool, and\n        // allocates a new one.\n        const pool = this._pool;\n        // Read the smaller of rest of the pool or however many bytes we want\n        const toRead = Math.min(pool.length - pool.used, bytesToRead);\n        const start = pool.used;\n        // the actual read.\n        debug('_read', 'reading', { start, toRead });\n        this.port.read(pool, start, toRead).then(({ bytesRead }) => {\n            debug('binding.read', 'finished', { bytesRead });\n            // zero bytes means read means we've hit EOF? Maybe this should be an error\n            if (bytesRead === 0) {\n                debug('binding.read', 'Zero bytes read closing readable stream');\n                this.push(null);\n                return;\n            }\n            pool.used += bytesRead;\n            this.push(pool.slice(start, start + bytesRead));\n        }, err => {\n            debug('binding.read', 'error', err);\n            if (!err.canceled) {\n                this._disconnected(err);\n            }\n            this._read(bytesToRead); // prime to read more once we're reconnected\n        });\n    }\n    _disconnected(err) {\n        if (!this.isOpen) {\n            debug('disconnected aborted because already closed', err);\n            return;\n        }\n        debug('disconnected', err);\n        this.close(undefined, new DisconnectedError(err.message));\n    }\n    /**\n     * Closes an open connection.\n     *\n     * If there are in progress writes when the port is closed the writes will error.\n     * @param {ErrorCallback} callback Called once a connection is closed.\n     * @param {Error} disconnectError used internally to propagate a disconnect error\n     */\n    close(callback, disconnectError = null) {\n        if (!this.isOpen || !this.port) {\n            debug('close attempted, but port is not open');\n            return this._asyncError(new Error('Port is not open'), callback);\n        }\n        this.closing = true;\n        debug('#close');\n        this.port.close().then(() => {\n            this.closing = false;\n            debug('binding.close', 'finished');\n            this.emit('close', disconnectError);\n            if (this.settings.endOnClose) {\n                this.emit('end');\n            }\n            if (callback) {\n                callback.call(this, disconnectError);\n            }\n        }, err => {\n            this.closing = false;\n            debug('binding.close', 'had an error', err);\n            return this._error(err, callback);\n        });\n    }\n    /**\n     * Set control flags on an open port. Uses [`SetCommMask`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363257(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for OS X and Linux.\n     *\n     * All options are operating system default when the port is opened. Every flag is set on each call to the provided or default values. If options isn't provided default options is used.\n     */\n    set(options, callback) {\n        if (!this.isOpen || !this.port) {\n            debug('set attempted, but port is not open');\n            return this._asyncError(new Error('Port is not open'), callback);\n        }\n        const settings = { ...defaultSetFlags, ...options };\n        debug('#set', settings);\n        this.port.set(settings).then(() => {\n            debug('binding.set', 'finished');\n            if (callback) {\n                callback.call(this, null);\n            }\n        }, err => {\n            debug('binding.set', 'had an error', err);\n            return this._error(err, callback);\n        });\n    }\n    /**\n     * Returns the control flags (CTS, DSR, DCD) on the open port.\n     * Uses [`GetCommModemStatus`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363258(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for mac and linux.\n     */\n    get(callback) {\n        if (!this.isOpen || !this.port) {\n            debug('get attempted, but port is not open');\n            return this._asyncError(new Error('Port is not open'), callback);\n        }\n        debug('#get');\n        this.port.get().then(status => {\n            debug('binding.get', 'finished');\n            callback.call(this, null, status);\n        }, err => {\n            debug('binding.get', 'had an error', err);\n            return this._error(err, callback);\n        });\n    }\n    /**\n     * Flush discards data received but not read, and written but not transmitted by the operating system. For more technical details, see [`tcflush(fd, TCIOFLUSH)`](http://linux.die.net/man/3/tcflush) for Mac/Linux and [`FlushFileBuffers`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439) for Windows.\n     */\n    flush(callback) {\n        if (!this.isOpen || !this.port) {\n            debug('flush attempted, but port is not open');\n            return this._asyncError(new Error('Port is not open'), callback);\n        }\n        debug('#flush');\n        this.port.flush().then(() => {\n            debug('binding.flush', 'finished');\n            if (callback) {\n                callback.call(this, null);\n            }\n        }, err => {\n            debug('binding.flush', 'had an error', err);\n            return this._error(err, callback);\n        });\n    }\n    /**\n     * Waits until all output data is transmitted to the serial port. After any pending write has completed it calls [`tcdrain()`](http://linux.die.net/man/3/tcdrain) or [FlushFileBuffers()](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364439(v=vs.85).aspx) to ensure it has been written to the device.\n    * @example\n    Write the `data` and wait until it has finished transmitting to the target serial port before calling the callback. This will queue until the port is open and writes are finished.\n  \n    ```js\n    function writeAndDrain (data, callback) {\n      port.write(data);\n      port.drain(callback);\n    }\n    ```\n    */\n    drain(callback) {\n        debug('drain');\n        if (!this.isOpen || !this.port) {\n            debug('drain queuing on port open');\n            this.once('open', () => {\n                this.drain(callback);\n            });\n            return;\n        }\n        this.port.drain().then(() => {\n            debug('binding.drain', 'finished');\n            if (callback) {\n                callback.call(this, null);\n            }\n        }, err => {\n            debug('binding.drain', 'had an error', err);\n            return this._error(err, callback);\n        });\n    }\n}\nexports.SerialPortStream = SerialPortStream;\n/**\n * The `error` event's callback is called with an error object whenever there is an error.\n * @event error\n */\n/**\n * The `open` event's callback is called with no arguments when the port is opened and ready for writing. This happens if you have the constructor open immediately (which opens in the next tick) or if you open the port manually with `open()`. See [Useage/Opening a Port](#opening-a-port) for more information.\n * @event open\n */\n/**\n * Request a number of bytes from the SerialPort. The `read()` method pulls some data out of the internal buffer and returns it. If no data is available to be read, null is returned. By default, the data is returned as a `Buffer` object unless an encoding has been specified using the `.setEncoding()` method.\n * @method SerialPort.prototype.read\n * @param {number=} size Specify how many bytes of data to return, if available\n * @returns {(string|Buffer|null)} The data from internal buffers\n */\n/**\n * Listening for the `data` event puts the port in flowing mode. Data is emitted as soon as it's received. Data is a `Buffer` object with a varying amount of data in it. The `readLine` parser converts the data into string lines. See the [parsers](https://serialport.io/docs/api-parsers-overview) section for more information on parsers, and the [Node.js stream documentation](https://nodejs.org/api/stream.html#stream_event_data) for more information on the data event.\n * @event data\n */\n/**\n * The `close` event's callback is called with no arguments when the port is closed. In the case of a disconnect it will be called with a Disconnect Error object (`err.disconnected == true`). In the event of a close error (unlikely), an error event is triggered.\n * @event close\n */\n/**\n * The `pause()` method causes a stream in flowing mode to stop emitting 'data' events, switching out of flowing mode. Any data that becomes available remains in the internal buffer.\n * @method SerialPort.prototype.pause\n * @see resume\n * @returns `this`\n */\n/**\n * The `resume()` method causes an explicitly paused, `Readable` stream to resume emitting 'data' events, switching the stream into flowing mode.\n * @method SerialPort.prototype.resume\n * @see pause\n * @returns `this`\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvc3RyZWFtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyx5QkFBeUI7QUFDcEQsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBK0Q7QUFDL0U7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQsb0RBQW9ELFdBQVc7QUFDL0QsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlib3ViZW5qYW1pbi9naXQvdHAtYXJtLXJhc3BiZXJyeS9ub2RlX21vZHVsZXMvQHNlcmlhbHBvcnQvc3RyZWFtL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcmlhbFBvcnRTdHJlYW0gPSBleHBvcnRzLkRpc2Nvbm5lY3RlZEVycm9yID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnc2VyaWFscG9ydC9zdHJlYW0nKTtcbmNsYXNzIERpc2Nvbm5lY3RlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGRpc2Nvbm5lY3RlZDtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5EaXNjb25uZWN0ZWRFcnJvciA9IERpc2Nvbm5lY3RlZEVycm9yO1xuY29uc3QgZGVmYXVsdFNldEZsYWdzID0ge1xuICAgIGJyazogZmFsc2UsXG4gICAgY3RzOiBmYWxzZSxcbiAgICBkdHI6IHRydWUsXG4gICAgcnRzOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGFsbG9jTmV3UmVhZFBvb2wocG9vbFNpemUpIHtcbiAgICBjb25zdCBwb29sID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBvb2xTaXplKTtcbiAgICBwb29sLnVzZWQgPSAwO1xuICAgIHJldHVybiBwb29sO1xufVxuY2xhc3MgU2VyaWFsUG9ydFN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgcG9ydDtcbiAgICBfcG9vbDtcbiAgICBfa01pblBvb2xTcGFjZTtcbiAgICBvcGVuaW5nO1xuICAgIGNsb3Npbmc7XG4gICAgc2V0dGluZ3M7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlcmlhbCBwb3J0IG9iamVjdCBmb3IgdGhlIGBwYXRoYC4gSW4gdGhlIGNhc2Ugb2YgaW52YWxpZCBhcmd1bWVudHMgb3IgaW52YWxpZCBvcHRpb25zLCB3aGVuIGNvbnN0cnVjdGluZyBhIG5ldyBTZXJpYWxQb3J0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoZSBwb3J0IHdpbGwgb3BlbiBhdXRvbWF0aWNhbGx5IGJ5IGRlZmF1bHQsIHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIGNhbGxpbmcgYHBvcnQub3BlbihvcGVuQ2FsbGJhY2spYCBpbiB0aGUgbmV4dCB0aWNrLiBZb3UgY2FuIGRpc2FibGUgdGhpcyBieSBzZXR0aW5nIHRoZSBvcHRpb24gYGF1dG9PcGVuYCB0byBgZmFsc2VgLlxuICAgICAqIEBlbWl0cyBvcGVuXG4gICAgICogQGVtaXRzIGRhdGFcbiAgICAgKiBAZW1pdHMgY2xvc2VcbiAgICAgKiBAZW1pdHMgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBvcGVuQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGVuZE9uQ2xvc2U6IGZhbHNlLFxuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogNjQgKiAxMDI0LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogc2V0dGluZ3MuaGlnaFdhdGVyTWFyayxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2V0dGluZ3MuYmluZGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJCaW5kaW5nc1wiIGlzIGludmFsaWQgcGFzcyBpdCBhcyBgb3B0aW9ucy5iaW5kaW5nYCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0dGluZ3MucGF0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJwYXRoXCIgaXMgbm90IGRlZmluZWQ6ICR7c2V0dGluZ3MucGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmJhdWRSYXRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJiYXVkUmF0ZVwiIG11c3QgYmUgYSBudW1iZXI6ICR7c2V0dGluZ3MuYmF1ZFJhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Bvb2wgPSBhbGxvY05ld1JlYWRQb29sKHRoaXMuc2V0dGluZ3MuaGlnaFdhdGVyTWFyayk7XG4gICAgICAgIHRoaXMuX2tNaW5Qb29sU3BhY2UgPSAxMjg7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9PcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4ob3BlbkNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucGF0aDtcbiAgICB9XG4gICAgZ2V0IGJhdWRSYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5iYXVkUmF0ZTtcbiAgICB9XG4gICAgZ2V0IGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBvcnQ/LmlzT3BlbiA/PyBmYWxzZSkgJiYgIXRoaXMuY2xvc2luZztcbiAgICB9XG4gICAgX2Vycm9yKGVycm9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXN5bmNFcnJvcihlcnJvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB0aGlzLl9lcnJvcihlcnJvciwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBjb25uZWN0aW9uIHRvIHRoZSBnaXZlbiBzZXJpYWwgcG9ydC5cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ2FsbGJhY2s9fSBvcGVuQ2FsbGJhY2sgLSBDYWxsZWQgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIG9wZW5lZC4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQgYW5kIGFuIGVycm9yIG9jY3VycywgaXQgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBwb3J0J3MgYGVycm9yYCBldmVudC5cbiAgICAgKiBAZW1pdHMgb3BlblxuICAgICAqL1xuICAgIG9wZW4ob3BlbkNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jRXJyb3IobmV3IEVycm9yKCdQb3J0IGlzIGFscmVhZHkgb3BlbicpLCBvcGVuQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0Vycm9yKG5ldyBFcnJvcignUG9ydCBpcyBvcGVuaW5nJyksIG9wZW5DYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IGhpZ2hXYXRlck1hcmssIGJpbmRpbmcsIGF1dG9PcGVuLCBlbmRPbkNsb3NlLCAuLi5vcGVuT3B0aW9ucyB9ID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgdGhpcy5vcGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgZGVidWcoJ29wZW5pbmcnLCBgcGF0aDogJHt0aGlzLnBhdGh9YCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYmluZGluZy5vcGVuKG9wZW5PcHRpb25zKS50aGVuKHBvcnQgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ29wZW5lZCcsIGBwYXRoOiAke3RoaXMucGF0aH1gKTtcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICAgICAgICAgICAgaWYgKG9wZW5DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wZW5DYWxsYmFjay5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBkZWJ1ZygnQmluZGluZyAjb3BlbiBoYWQgYW4gZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyLCBvcGVuQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgYmF1ZCByYXRlIGZvciBhbiBvcGVuIHBvcnQuIEVtaXRzIGFuIGVycm9yIG9yIGNhbGxzIHRoZSBjYWxsYmFjayBpZiB0aGUgYmF1ZCByYXRlIGlzbid0IHN1cHBvcnRlZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT25seSBzdXBwb3J0cyBgYmF1ZFJhdGVgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gW29wdGlvbnMuYmF1ZFJhdGVdIFRoZSBiYXVkIHJhdGUgb2YgdGhlIHBvcnQgdG8gYmUgb3BlbmVkLiBUaGlzIHNob3VsZCBtYXRjaCBvbmUgb2YgdGhlIGNvbW1vbmx5IGF2YWlsYWJsZSBiYXVkIHJhdGVzLCBzdWNoIGFzIDExMCwgMzAwLCAxMjAwLCAyNDAwLCA0ODAwLCA5NjAwLCAxNDQwMCwgMTkyMDAsIDM4NDAwLCA1NzYwMCwgb3IgMTE1MjAwLiBDdXN0b20gcmF0ZXMgYXJlIHN1cHBvcnRlZCBiZXN0IGVmZm9ydCBwZXIgcGxhdGZvcm0uIFRoZSBkZXZpY2UgY29ubmVjdGVkIHRvIHRoZSBzZXJpYWwgcG9ydCBpcyBub3QgZ3VhcmFudGVlZCB0byBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgYmF1ZCByYXRlLCBldmVuIGlmIHRoZSBwb3J0IGl0c2VsZiBzdXBwb3J0cyB0aGF0IGJhdWQgcmF0ZS5cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ2FsbGJhY2s9fSBbY2FsbGJhY2tdIENhbGxlZCBvbmNlIHRoZSBwb3J0J3MgYmF1ZCByYXRlIGNoYW5nZXMuIElmIGAudXBkYXRlYCBpcyBjYWxsZWQgd2l0aG91dCBhIGNhbGxiYWNrLCBhbmQgdGhlcmUgaXMgYW4gZXJyb3IsIGFuIGVycm9yIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB1cGRhdGUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5wb3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZygndXBkYXRlIGF0dGVtcHRlZCwgYnV0IHBvcnQgaXMgbm90IG9wZW4nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0Vycm9yKG5ldyBFcnJvcignUG9ydCBpcyBub3Qgb3BlbicpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3VwZGF0ZScsIGBiYXVkUmF0ZTogJHtvcHRpb25zLmJhdWRSYXRlfWApO1xuICAgICAgICB0aGlzLnBvcnQudXBkYXRlKG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ2JpbmRpbmcudXBkYXRlJywgJ2ZpbmlzaGVkJyk7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmJhdWRSYXRlID0gb3B0aW9ucy5iYXVkUmF0ZTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBkZWJ1ZygnYmluZGluZy51cGRhdGUnLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVyciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgX3dyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ193cml0ZScsIGAke2RhdGEubGVuZ3RofSBieXRlcyBvZiBkYXRhYCk7XG4gICAgICAgIHRoaXMucG9ydC53cml0ZShkYXRhKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdiaW5kaW5nLndyaXRlJywgJ3dyaXRlIGZpbmlzaGVkJyk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdiaW5kaW5nLndyaXRlJywgJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIGlmICghZXJyLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3dyaXRldihkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZygnX3dyaXRldicsIGAke2RhdGEubGVuZ3RofSBjaHVua3Mgb2YgZGF0YWApO1xuICAgICAgICBjb25zdCBkYXRhViA9IGRhdGEubWFwKHdyaXRlID0+IHdyaXRlLmNodW5rKTtcbiAgICAgICAgdGhpcy5fd3JpdGUoQnVmZmVyLmNvbmNhdChkYXRhViksICdiaW5hcnknLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIF9yZWFkKGJ5dGVzVG9SZWFkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gfHwgIXRoaXMucG9ydCkge1xuICAgICAgICAgICAgZGVidWcoJ19yZWFkJywgJ3F1ZXVlaW5nIF9yZWFkIGZvciBhZnRlciBvcGVuJyk7XG4gICAgICAgICAgICB0aGlzLm9uY2UoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZChieXRlc1RvUmVhZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3Bvb2wgfHwgdGhpcy5fcG9vbC5sZW5ndGggLSB0aGlzLl9wb29sLnVzZWQgPCB0aGlzLl9rTWluUG9vbFNwYWNlKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX3JlYWQnLCAnZGlzY2FyZGluZyB0aGUgcmVhZCBidWZmZXIgcG9vbCBiZWNhdXNlIGl0IGlzIGJlbG93IGtNaW5Qb29sU3BhY2UnKTtcbiAgICAgICAgICAgIHRoaXMuX3Bvb2wgPSBhbGxvY05ld1JlYWRQb29sKHRoaXMuc2V0dGluZ3MuaGlnaFdhdGVyTWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR3JhYiBhbm90aGVyIHJlZmVyZW5jZSB0byB0aGUgcG9vbCBpbiB0aGUgY2FzZSB0aGF0IHdoaWxlIHdlJ3JlXG4gICAgICAgIC8vIGluIHRoZSB0aHJlYWQgcG9vbCBhbm90aGVyIHJlYWQoKSBmaW5pc2hlcyB1cCB0aGUgcG9vbCwgYW5kXG4gICAgICAgIC8vIGFsbG9jYXRlcyBhIG5ldyBvbmUuXG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLl9wb29sO1xuICAgICAgICAvLyBSZWFkIHRoZSBzbWFsbGVyIG9mIHJlc3Qgb2YgdGhlIHBvb2wgb3IgaG93ZXZlciBtYW55IGJ5dGVzIHdlIHdhbnRcbiAgICAgICAgY29uc3QgdG9SZWFkID0gTWF0aC5taW4ocG9vbC5sZW5ndGggLSBwb29sLnVzZWQsIGJ5dGVzVG9SZWFkKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwb29sLnVzZWQ7XG4gICAgICAgIC8vIHRoZSBhY3R1YWwgcmVhZC5cbiAgICAgICAgZGVidWcoJ19yZWFkJywgJ3JlYWRpbmcnLCB7IHN0YXJ0LCB0b1JlYWQgfSk7XG4gICAgICAgIHRoaXMucG9ydC5yZWFkKHBvb2wsIHN0YXJ0LCB0b1JlYWQpLnRoZW4oKHsgYnl0ZXNSZWFkIH0pID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdiaW5kaW5nLnJlYWQnLCAnZmluaXNoZWQnLCB7IGJ5dGVzUmVhZCB9KTtcbiAgICAgICAgICAgIC8vIHplcm8gYnl0ZXMgbWVhbnMgcmVhZCBtZWFucyB3ZSd2ZSBoaXQgRU9GPyBNYXliZSB0aGlzIHNob3VsZCBiZSBhbiBlcnJvclxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdiaW5kaW5nLnJlYWQnLCAnWmVybyBieXRlcyByZWFkIGNsb3NpbmcgcmVhZGFibGUgc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvb2wudXNlZCArPSBieXRlc1JlYWQ7XG4gICAgICAgICAgICB0aGlzLnB1c2gocG9vbC5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlc1JlYWQpKTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdiaW5kaW5nLnJlYWQnLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgaWYgKCFlcnIuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNjb25uZWN0ZWQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlYWQoYnl0ZXNUb1JlYWQpOyAvLyBwcmltZSB0byByZWFkIG1vcmUgb25jZSB3ZSdyZSByZWNvbm5lY3RlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2Rpc2Nvbm5lY3RlZChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCBhYm9ydGVkIGJlY2F1c2UgYWxyZWFkeSBjbG9zZWQnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuICAgICAgICB0aGlzLmNsb3NlKHVuZGVmaW5lZCwgbmV3IERpc2Nvbm5lY3RlZEVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbiBvcGVuIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBhcmUgaW4gcHJvZ3Jlc3Mgd3JpdGVzIHdoZW4gdGhlIHBvcnQgaXMgY2xvc2VkIHRoZSB3cml0ZXMgd2lsbCBlcnJvci5cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZGlzY29ubmVjdEVycm9yIHVzZWQgaW50ZXJuYWxseSB0byBwcm9wYWdhdGUgYSBkaXNjb25uZWN0IGVycm9yXG4gICAgICovXG4gICAgY2xvc2UoY2FsbGJhY2ssIGRpc2Nvbm5lY3RFcnJvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5wb3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnY2xvc2UgYXR0ZW1wdGVkLCBidXQgcG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jRXJyb3IobmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NpbmcgPSB0cnVlO1xuICAgICAgICBkZWJ1ZygnI2Nsb3NlJyk7XG4gICAgICAgIHRoaXMucG9ydC5jbG9zZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBkZWJ1ZygnYmluZGluZy5jbG9zZScsICdmaW5pc2hlZCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIGRpc2Nvbm5lY3RFcnJvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmRPbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZGlzY29ubmVjdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZGVidWcoJ2JpbmRpbmcuY2xvc2UnLCAnaGFkIGFuIGVycm9yJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcihlcnIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjb250cm9sIGZsYWdzIG9uIGFuIG9wZW4gcG9ydC4gVXNlcyBbYFNldENvbW1NYXNrYF0oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzNjMyNTcodj12cy44NSkuYXNweCkgZm9yIFdpbmRvd3MgYW5kIFtgaW9jdGxgXShodHRwOi8vbGludXguZGllLm5ldC9tYW4vNC90dHlfaW9jdGwpIGZvciBPUyBYIGFuZCBMaW51eC5cbiAgICAgKlxuICAgICAqIEFsbCBvcHRpb25zIGFyZSBvcGVyYXRpbmcgc3lzdGVtIGRlZmF1bHQgd2hlbiB0aGUgcG9ydCBpcyBvcGVuZWQuIEV2ZXJ5IGZsYWcgaXMgc2V0IG9uIGVhY2ggY2FsbCB0byB0aGUgcHJvdmlkZWQgb3IgZGVmYXVsdCB2YWx1ZXMuIElmIG9wdGlvbnMgaXNuJ3QgcHJvdmlkZWQgZGVmYXVsdCBvcHRpb25zIGlzIHVzZWQuXG4gICAgICovXG4gICAgc2V0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gfHwgIXRoaXMucG9ydCkge1xuICAgICAgICAgICAgZGVidWcoJ3NldCBhdHRlbXB0ZWQsIGJ1dCBwb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXN5bmNFcnJvcihuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0geyAuLi5kZWZhdWx0U2V0RmxhZ3MsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgZGVidWcoJyNzZXQnLCBzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMucG9ydC5zZXQoc2V0dGluZ3MpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ2JpbmRpbmcuc2V0JywgJ2ZpbmlzaGVkJyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ2JpbmRpbmcuc2V0JywgJ2hhZCBhbiBlcnJvcicsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoZXJyLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sIGZsYWdzIChDVFMsIERTUiwgRENEKSBvbiB0aGUgb3BlbiBwb3J0LlxuICAgICAqIFVzZXMgW2BHZXRDb21tTW9kZW1TdGF0dXNgXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM2MzI1OCh2PXZzLjg1KS5hc3B4KSBmb3IgV2luZG93cyBhbmQgW2Bpb2N0bGBdKGh0dHA6Ly9saW51eC5kaWUubmV0L21hbi80L3R0eV9pb2N0bCkgZm9yIG1hYyBhbmQgbGludXguXG4gICAgICovXG4gICAgZ2V0KGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gfHwgIXRoaXMucG9ydCkge1xuICAgICAgICAgICAgZGVidWcoJ2dldCBhdHRlbXB0ZWQsIGJ1dCBwb3J0IGlzIG5vdCBvcGVuJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXN5bmNFcnJvcihuZXcgRXJyb3IoJ1BvcnQgaXMgbm90IG9wZW4nKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCcjZ2V0Jyk7XG4gICAgICAgIHRoaXMucG9ydC5nZXQoKS50aGVuKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICBkZWJ1ZygnYmluZGluZy5nZXQnLCAnZmluaXNoZWQnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbnVsbCwgc3RhdHVzKTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdiaW5kaW5nLmdldCcsICdoYWQgYW4gZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVyciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2ggZGlzY2FyZHMgZGF0YSByZWNlaXZlZCBidXQgbm90IHJlYWQsIGFuZCB3cml0dGVuIGJ1dCBub3QgdHJhbnNtaXR0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0uIEZvciBtb3JlIHRlY2huaWNhbCBkZXRhaWxzLCBzZWUgW2B0Y2ZsdXNoKGZkLCBUQ0lPRkxVU0gpYF0oaHR0cDovL2xpbnV4LmRpZS5uZXQvbWFuLzMvdGNmbHVzaCkgZm9yIE1hYy9MaW51eCBhbmQgW2BGbHVzaEZpbGVCdWZmZXJzYF0oaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM2NDQzOSkgZm9yIFdpbmRvd3MuXG4gICAgICovXG4gICAgZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5wb3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnZmx1c2ggYXR0ZW1wdGVkLCBidXQgcG9ydCBpcyBub3Qgb3BlbicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jRXJyb3IobmV3IEVycm9yKCdQb3J0IGlzIG5vdCBvcGVuJyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnI2ZsdXNoJyk7XG4gICAgICAgIHRoaXMucG9ydC5mbHVzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ2JpbmRpbmcuZmx1c2gnLCAnZmluaXNoZWQnKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBkZWJ1ZygnYmluZGluZy5mbHVzaCcsICdoYWQgYW4gZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVyciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgYWxsIG91dHB1dCBkYXRhIGlzIHRyYW5zbWl0dGVkIHRvIHRoZSBzZXJpYWwgcG9ydC4gQWZ0ZXIgYW55IHBlbmRpbmcgd3JpdGUgaGFzIGNvbXBsZXRlZCBpdCBjYWxscyBbYHRjZHJhaW4oKWBdKGh0dHA6Ly9saW51eC5kaWUubmV0L21hbi8zL3RjZHJhaW4pIG9yIFtGbHVzaEZpbGVCdWZmZXJzKCldKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzY0NDM5KHY9dnMuODUpLmFzcHgpIHRvIGVuc3VyZSBpdCBoYXMgYmVlbiB3cml0dGVuIHRvIHRoZSBkZXZpY2UuXG4gICAgKiBAZXhhbXBsZVxuICAgIFdyaXRlIHRoZSBgZGF0YWAgYW5kIHdhaXQgdW50aWwgaXQgaGFzIGZpbmlzaGVkIHRyYW5zbWl0dGluZyB0byB0aGUgdGFyZ2V0IHNlcmlhbCBwb3J0IGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFjay4gVGhpcyB3aWxsIHF1ZXVlIHVudGlsIHRoZSBwb3J0IGlzIG9wZW4gYW5kIHdyaXRlcyBhcmUgZmluaXNoZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gd3JpdGVBbmREcmFpbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIHBvcnQud3JpdGUoZGF0YSk7XG4gICAgICBwb3J0LmRyYWluKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYGBgXG4gICAgKi9cbiAgICBkcmFpbihjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZygnZHJhaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5wb3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnZHJhaW4gcXVldWluZyBvbiBwb3J0IG9wZW4nKTtcbiAgICAgICAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9ydC5kcmFpbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ2JpbmRpbmcuZHJhaW4nLCAnZmluaXNoZWQnKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBkZWJ1ZygnYmluZGluZy5kcmFpbicsICdoYWQgYW4gZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVyciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcmlhbFBvcnRTdHJlYW0gPSBTZXJpYWxQb3J0U3RyZWFtO1xuLyoqXG4gKiBUaGUgYGVycm9yYCBldmVudCdzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIGFuIGVycm9yIG9iamVjdCB3aGVuZXZlciB0aGVyZSBpcyBhbiBlcnJvci5cbiAqIEBldmVudCBlcnJvclxuICovXG4vKipcbiAqIFRoZSBgb3BlbmAgZXZlbnQncyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgd2hlbiB0aGUgcG9ydCBpcyBvcGVuZWQgYW5kIHJlYWR5IGZvciB3cml0aW5nLiBUaGlzIGhhcHBlbnMgaWYgeW91IGhhdmUgdGhlIGNvbnN0cnVjdG9yIG9wZW4gaW1tZWRpYXRlbHkgKHdoaWNoIG9wZW5zIGluIHRoZSBuZXh0IHRpY2spIG9yIGlmIHlvdSBvcGVuIHRoZSBwb3J0IG1hbnVhbGx5IHdpdGggYG9wZW4oKWAuIFNlZSBbVXNlYWdlL09wZW5pbmcgYSBQb3J0XSgjb3BlbmluZy1hLXBvcnQpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQGV2ZW50IG9wZW5cbiAqL1xuLyoqXG4gKiBSZXF1ZXN0IGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gdGhlIFNlcmlhbFBvcnQuIFRoZSBgcmVhZCgpYCBtZXRob2QgcHVsbHMgc29tZSBkYXRhIG91dCBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFuZCByZXR1cm5zIGl0LiBJZiBubyBkYXRhIGlzIGF2YWlsYWJsZSB0byBiZSByZWFkLCBudWxsIGlzIHJldHVybmVkLiBCeSBkZWZhdWx0LCB0aGUgZGF0YSBpcyByZXR1cm5lZCBhcyBhIGBCdWZmZXJgIG9iamVjdCB1bmxlc3MgYW4gZW5jb2RpbmcgaGFzIGJlZW4gc3BlY2lmaWVkIHVzaW5nIHRoZSBgLnNldEVuY29kaW5nKClgIG1ldGhvZC5cbiAqIEBtZXRob2QgU2VyaWFsUG9ydC5wcm90b3R5cGUucmVhZFxuICogQHBhcmFtIHtudW1iZXI9fSBzaXplIFNwZWNpZnkgaG93IG1hbnkgYnl0ZXMgb2YgZGF0YSB0byByZXR1cm4sIGlmIGF2YWlsYWJsZVxuICogQHJldHVybnMgeyhzdHJpbmd8QnVmZmVyfG51bGwpfSBUaGUgZGF0YSBmcm9tIGludGVybmFsIGJ1ZmZlcnNcbiAqL1xuLyoqXG4gKiBMaXN0ZW5pbmcgZm9yIHRoZSBgZGF0YWAgZXZlbnQgcHV0cyB0aGUgcG9ydCBpbiBmbG93aW5nIG1vZGUuIERhdGEgaXMgZW1pdHRlZCBhcyBzb29uIGFzIGl0J3MgcmVjZWl2ZWQuIERhdGEgaXMgYSBgQnVmZmVyYCBvYmplY3Qgd2l0aCBhIHZhcnlpbmcgYW1vdW50IG9mIGRhdGEgaW4gaXQuIFRoZSBgcmVhZExpbmVgIHBhcnNlciBjb252ZXJ0cyB0aGUgZGF0YSBpbnRvIHN0cmluZyBsaW5lcy4gU2VlIHRoZSBbcGFyc2Vyc10oaHR0cHM6Ly9zZXJpYWxwb3J0LmlvL2RvY3MvYXBpLXBhcnNlcnMtb3ZlcnZpZXcpIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcGFyc2VycywgYW5kIHRoZSBbTm9kZS5qcyBzdHJlYW0gZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fZXZlbnRfZGF0YSkgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIGRhdGEgZXZlbnQuXG4gKiBAZXZlbnQgZGF0YVxuICovXG4vKipcbiAqIFRoZSBgY2xvc2VgIGV2ZW50J3MgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzIHdoZW4gdGhlIHBvcnQgaXMgY2xvc2VkLiBJbiB0aGUgY2FzZSBvZiBhIGRpc2Nvbm5lY3QgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIERpc2Nvbm5lY3QgRXJyb3Igb2JqZWN0IChgZXJyLmRpc2Nvbm5lY3RlZCA9PSB0cnVlYCkuIEluIHRoZSBldmVudCBvZiBhIGNsb3NlIGVycm9yICh1bmxpa2VseSksIGFuIGVycm9yIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAqIEBldmVudCBjbG9zZVxuICovXG4vKipcbiAqIFRoZSBgcGF1c2UoKWAgbWV0aG9kIGNhdXNlcyBhIHN0cmVhbSBpbiBmbG93aW5nIG1vZGUgdG8gc3RvcCBlbWl0dGluZyAnZGF0YScgZXZlbnRzLCBzd2l0Y2hpbmcgb3V0IG9mIGZsb3dpbmcgbW9kZS4gQW55IGRhdGEgdGhhdCBiZWNvbWVzIGF2YWlsYWJsZSByZW1haW5zIGluIHRoZSBpbnRlcm5hbCBidWZmZXIuXG4gKiBAbWV0aG9kIFNlcmlhbFBvcnQucHJvdG90eXBlLnBhdXNlXG4gKiBAc2VlIHJlc3VtZVxuICogQHJldHVybnMgYHRoaXNgXG4gKi9cbi8qKlxuICogVGhlIGByZXN1bWUoKWAgbWV0aG9kIGNhdXNlcyBhbiBleHBsaWNpdGx5IHBhdXNlZCwgYFJlYWRhYmxlYCBzdHJlYW0gdG8gcmVzdW1lIGVtaXR0aW5nICdkYXRhJyBldmVudHMsIHN3aXRjaGluZyB0aGUgc3RyZWFtIGludG8gZmxvd2luZyBtb2RlLlxuICogQG1ldGhvZCBTZXJpYWxQb3J0LnByb3RvdHlwZS5yZXN1bWVcbiAqIEBzZWUgcGF1c2VcbiAqIEByZXR1cm5zIGB0aGlzYFxuICovXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@serialport/stream/dist/index.js\n");

/***/ })

};
;